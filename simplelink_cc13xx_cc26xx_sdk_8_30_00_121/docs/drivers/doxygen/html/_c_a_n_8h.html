<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>CAN.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="dir_dd8fa7f0a423552d37651735ac37558f.html">ti</a></li><li class="navelem"><a class="el" href="dir_15fb9a92674a5e15cac1f3112cfb19ae.html">drivers</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">CAN.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Controller Area Network (CAN) Driver Interface. </p>
<hr/>
<p><a class="anchor" id="ti_drivers_CAN_Overview"></a></p><h1>Overview</h1>
<p>The Controller Area Network (CAN) driver is a single instance driver that provides a simple interface to transmit and receive messages on a CAN bus. Messages are broadcast to the entire CAN network and each device is responsible for filtering and handling the received messages as necessary. The application is responsible for interpreting the received data.</p>
<h1>Power Management</h1>
<p>For devices with an integrated CAN controller, the CAN driver sets a power constraint when the driver is opened to prevent the device from entering standby when all tasks are blocked. This is required to allow the CAN controller and its clock source to remain powered to receive CAN messages from the external CAN transceiver. When the driver is closed, the power constraint is released. The application should close the CAN driver whenever the CAN transceiver enters sleep mode and re-open the CAN driver when the CAN transceiver wakes from sleep mode.</p>
<hr/>
<p> <a class="anchor" id="ti_drivers_CAN_Usage"></a></p><h1>Usage</h1>
<p>To use the CAN driver to send and receive messages over the CAN bus, the application calls the following APIs:</p><ul>
<li><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a>: Open the CAN driver instance and configure the CAN controller, placing it in normal operational mode.</li>
<li><a class="el" href="_c_a_n_8h.html#ab670eb9a60e4f12c2eab6df7c2fa87e5" title="Sends CAN message using the Tx FIFO/Queue. ">CAN_write()</a>: Transmit a message using the Tx FIFO/Queue. This is the typical method of transmission.</li>
<li><a class="el" href="_c_a_n_8h.html#a5faff3ed36a87d3459a2870f4e622d25" title="Sends CAN message using a dedicated Tx Buffer. ">CAN_writeBuffer()</a>: Transmit a message using a dedicated Tx Buffer. This method of transmission requires a custom message RAM configuration and should only be used if there is an application-specific need that cannot be met by using the Tx FIFO/Queue.</li>
<li><a class="el" href="_c_a_n_8h.html#a515269a858d44d1ed043ccd37f3eedcb" title="Reads a received CAN message. ">CAN_read()</a>: Receive a message. This should be called in a task context and triggered by the event callback when CAN_EVENT_RX_DATA_AVAIL occurs.</li>
<li><a class="el" href="_c_a_n_8h.html#abfc2ccd7bffde7724a17ab6c7e69f5cf" title="Closes a CAN peripheral specified by handle. ">CAN_close()</a>: Close the CAN driver instance and reset the CAN controller, placing it in standby operational mode.</li>
</ul>
<p><a class="anchor" id="ti_drivers_CAN_Synopsis"></a></p><h2>Synopsis</h2>
<p>The following code example initializes the CAN driver with the default configuration, transmits a CAN FD message, and waits to read any received messages.</p>
<div class="fragment"><div class="line"><span class="comment">// Payload data size indexed by Data Length Code (DLC) field.</span></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> uint32_t dlcToDataSize[16] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 12, 16, 20, 24, 32, 48, 64};</div><div class="line"></div><div class="line"><span class="comment">// Rx semaphore.</span></div><div class="line"><span class="keyword">static</span> <a class="code" href="_semaphore_p_8h.html#a7f34865f33e666455692544e5f12d1f2">SemaphoreP_Handle</a> rxSemHandle;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> eventCallback(<a class="code" href="struct_c_a_n___config__.html">CAN_Handle</a> handle, uint32_t event, uint32_t data, <span class="keywordtype">void</span> *userArg)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (event == <a class="code" href="group___c_a_n___e_v_e_n_t.html#ga7b6db1c1518135c8d1631a961ceb6e47">CAN_EVENT_RX_DATA_AVAIL</a>)</div><div class="line">    {</div><div class="line">        <a class="code" href="_semaphore_p_8h.html#a88ae04fe7807a199d1bf06cea651474a">SemaphoreP_post</a>(rxSemHandle);</div><div class="line">    }</div><div class="line">    <span class="comment">// Handle more events here if enabled via the event mask...</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> thread(arg0, arg1)</div><div class="line">{</div><div class="line">   int_fast16_t status;</div><div class="line">   <a class="code" href="struct_m_c_a_n___rx_buf_element.html">CAN_RxBufElement</a> rxElem;</div><div class="line">   <a class="code" href="struct_m_c_a_n___tx_buf_element.html">CAN_TxBufElement</a> txElem;</div><div class="line"></div><div class="line">   <span class="comment">// Initialize driver(s).</span></div><div class="line">   <a class="code" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31">CAN_init</a>();</div><div class="line"></div><div class="line">   <span class="comment">// Create callback semaphore.</span></div><div class="line">   <a class="code" href="struct_semaphore_p___params.html">SemaphoreP_Params</a> semParams;</div><div class="line">   <a class="code" href="_semaphore_p_8h.html#a5a2deea3033e8a6aa2564637958efd02">SemaphoreP_Params_init</a>(&amp;semParams);</div><div class="line">   semParams.<a class="code" href="struct_semaphore_p___params.html#a4d12bb8c19485dd4d4fe2616a41a9948">mode</a>    = <a class="code" href="_semaphore_p_8h.html#add3b3b8c066d33d0067fac18e839f8ffacf53dfcfc30e664856ba170da10bde91">SemaphoreP_Mode_BINARY</a>;</div><div class="line">   callbackSemHandle = <a class="code" href="_semaphore_p_8h.html#a3fd837348befa046554496e8da2a1fac">SemaphoreP_create</a>(0, &amp;(semParams));</div><div class="line"></div><div class="line">   <span class="keywordflow">if</span> (callbackSemHandle == NULL)</div><div class="line">   {</div><div class="line">       <span class="comment">// SemaphoreP_create() failed.</span></div><div class="line">       <span class="keywordflow">while</span> (1) {}</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Open CAN driver with default configuration.</span></div><div class="line">   <a class="code" href="_c_a_n_8h.html#a9a7a7042e4948d4e04b9cb5205c50acf">CAN_Params_init</a>(&amp;canParams);</div><div class="line">   canParams.eventCbk  = eventCallback;</div><div class="line">   <span class="comment">// Setup event mask for events the application is interested in receiving</span></div><div class="line">   <span class="comment">// the callback for. Typically, only the CAN_EVENT_RX_DATA_AVAIL is required.</span></div><div class="line">   canParams.eventMask = <a class="code" href="group___c_a_n___e_v_e_n_t.html#ga7b6db1c1518135c8d1631a961ceb6e47">CAN_EVENT_RX_DATA_AVAIL</a>;</div><div class="line"></div><div class="line">   canHandle = <a class="code" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4">CAN_open</a>(CONFIG_CAN_0, &amp;canParams);</div><div class="line">   <span class="keywordflow">if</span> (canHandle == NULL)</div><div class="line">   {</div><div class="line">       <span class="comment">// CAN_open() failed.</span></div><div class="line">       <span class="keywordflow">while</span> (1) {}</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Setup Tx buffer element:</span></div><div class="line">   <span class="comment">//   CAN FD without Bit Rate Switching</span></div><div class="line">   <span class="comment">//   Extended Message ID = 0x12345678</span></div><div class="line">   <span class="comment">//   Data Length of 64-bytes</span></div><div class="line">   <span class="comment">//   Message marker = 5</span></div><div class="line">   txElem.<a class="code" href="struct_m_c_a_n___tx_buf_element.html#a2ba679095ae9a3f3a80fe67d6e6ac976">id</a>  = 0x12345678U;</div><div class="line">   txElem.<a class="code" href="struct_m_c_a_n___tx_buf_element.html#a7208cc6dc9cb4233a221f46e882481c9">rtr</a> = 0U;</div><div class="line">   txElem.<a class="code" href="struct_m_c_a_n___tx_buf_element.html#a16ab6d944c3606c7001af8614f20ce8d">xtd</a> = 1U;</div><div class="line">   txElem.<a class="code" href="struct_m_c_a_n___tx_buf_element.html#aa592a27fa37f3a59820d31756fa37e7a">esi</a> = 0U;</div><div class="line">   txElem.<a class="code" href="struct_m_c_a_n___tx_buf_element.html#a1a09aea55a081878f79be58687d73ac3">brs</a> = 1U;</div><div class="line">   txElem.<a class="code" href="struct_m_c_a_n___tx_buf_element.html#a3fcc0f7ff296a10df9e019b27a155200">dlc</a> = <a class="code" href="group___c_a_n___d_l_c.html#ga36d05d20d54c1602c8f53b23dd12b842">CAN_DLC_64B</a>;</div><div class="line">   txElem.<a class="code" href="struct_m_c_a_n___tx_buf_element.html#a839ab3988c79f93eb00a0bef113cde42">fdf</a> = 1U;</div><div class="line">   txElem.<a class="code" href="struct_m_c_a_n___tx_buf_element.html#aa9b414b14157f2f1b1732bc05f3d796d">efc</a> = 0U;</div><div class="line">   txElem.<a class="code" href="struct_m_c_a_n___tx_buf_element.html#af087e40af98a5c7d3d76036edecd5fcd">mm</a>  = 5U;</div><div class="line"></div><div class="line">   <span class="comment">// Fill data payload with incrementing values.</span></div><div class="line">   <span class="keywordflow">for</span> (i = 0; i &lt; dlcToDataSize[txElem.<a class="code" href="struct_m_c_a_n___tx_buf_element.html#a3fcc0f7ff296a10df9e019b27a155200">dlc</a>]; i++)</div><div class="line">   {</div><div class="line">       txElem.<a class="code" href="struct_m_c_a_n___tx_buf_element.html#a5b5d4dc1e7e7f208259cdc5e34e55275">data</a>[i] = i;</div><div class="line">   }</div><div class="line"></div><div class="line">   <span class="comment">// Transmit message.</span></div><div class="line">   <a class="code" href="_c_a_n_8h.html#ab670eb9a60e4f12c2eab6df7c2fa87e5">CAN_write</a>(canHandle, &amp;txElem);</div><div class="line"></div><div class="line">   <span class="keywordflow">while</span> (1)</div><div class="line">   {</div><div class="line">       <span class="comment">// Wait for Rx data available event.</span></div><div class="line">       <a class="code" href="_semaphore_p_8h.html#a375d7e0596970995eaa2c2bc77d7acb3">SemaphoreP_pend</a>(rxSemHandle, (uint32_t)<a class="code" href="_semaphore_p_8h.html#a6d1991df030b91d441c8bc886739c29d">SemaphoreP_WAIT_FOREVER</a>);</div><div class="line"></div><div class="line">       <span class="comment">// Read all available messages.</span></div><div class="line">       <span class="keywordflow">while</span> (<a class="code" href="_c_a_n_8h.html#a515269a858d44d1ed043ccd37f3eedcb">CAN_read</a>(canHandle, &amp;rxElem) == <a class="code" href="group___c_a_n___s_t_a_t_u_s.html#gaec519b2472a0cb3c778a1e2cffd7de5d">CAN_STATUS_SUCCESS</a>)</div><div class="line">       {</div><div class="line">           <span class="comment">// Process received message.</span></div><div class="line">       }</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p>More details on usage are provided in the following subsections.</p>
<p><a class="anchor" id="ti_drivers_CAN_Examples"></a></p><h2>Examples</h2>
<ul>
<li><a class="el" href="_c_a_n_8h.html#ti_drivers_CAN_Synopsis">Usage Synopsis</a></li>
<li><a class="el" href="_c_a_n_8h.html#ti_drivers_CAN_Example_initMsgRam">Initialize with custom message RAM configuration</a></li>
<li><a class="el" href="_c_a_n_8h.html#ti_drivers_CAN_Example_initRawBitRate">Initialize with raw bit rate timing</a></li>
</ul>
<h2>Initializing the CAN Driver</h2>
<p><a class="el" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31" title="This function initializes the CAN module. ">CAN_init()</a> must be called before any other CAN APIs. This function initializes common driver resources and calls the device-specific initialization function to configure the bit rate and message RAM.</p>
<h2>Opening the CAN Driver</h2>
<p>After initializing the CAN driver by calling <a class="el" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31" title="This function initializes the CAN module. ">CAN_init()</a>, the application can open a CAN instance by calling <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a>. This function takes an index into the <code>CAN_config</code>[] array, and a CAN parameters data structure. The CAN instance is specified by the index of the CAN in <code>CAN_config</code>[]. Calling <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a> a second time with the same index previously passed to <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a> will result in an error. You can, though, re-use the index if the instance is closed via <a class="el" href="_c_a_n_8h.html#abfc2ccd7bffde7724a17ab6c7e69f5cf" title="Closes a CAN peripheral specified by handle. ">CAN_close()</a>.</p>
<p>If no <a class="el" href="struct_c_a_n___params.html" title="CAN Parameters. ">CAN_Params</a> structure is passed to <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a>, default values are used. If the open call is successful, it returns a non-NULL value. The CAN driver APIs are non-blocking; there is no configurable return behavior.</p>
<p><a class="anchor" id="ti_drivers_CAN_Example_initMsgRam"></a> Example initializing the CAN driver with a custom message RAM configuration to receive only filtered message IDs:</p>
<dl class="section note"><dt>Note</dt><dd>CAN driver SysConfig must be setup with 'Reject Non-Matching Messages' enabled.</dd></dl>
<div class="fragment"><div class="line"><span class="preprocessor">#define STD_MSG_FILTER_NUM 2U</span></div><div class="line"><span class="preprocessor">#define EXT_MSG_FILTER_NUM 1U</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="struct_m_c_a_n___std_msg_i_d_filter_element.html">MCAN_StdMsgIDFilterElement</a> stdMsgIDFilter[STD_MSG_FILTER_NUM] =</div><div class="line">    {{.<a class="code" href="struct_m_c_a_n___std_msg_i_d_filter_element.html#a810be26bca69b7c105bc9a8f445cd0ba">sfid1</a> = 0x555, .sfid2 = 0x444, .sfec = <a class="code" href="group___c_a_n___f_e_c.html#gae8a4569aef9c12b6f3cfc7bacc4573b2">CAN_FEC_STORE_RXFIFO0</a>, .sft = <a class="code" href="group___c_a_n___f_i_l_t_e_r___t_y_p_e.html#gae9661fdc40f3f402cd7d273105271303">CAN_FILTER_DUAL_ID</a>},</div><div class="line">     {.sfid1 = 0x123, .sfid2 = 0U, .sfec = <a class="code" href="group___c_a_n___f_e_c.html#ga62ba101b4434f8b1169c4f6ca1fc6423">CAN_FEC_STORE_RXBUF</a>, .sft = 0U}};</div><div class="line"></div><div class="line"><span class="keyword">static</span> <a class="code" href="struct_m_c_a_n___ext_msg_i_d_filter_element.html">MCAN_ExtMsgIDFilterElement</a> extMsgIDFilter[EXT_MSG_FILTER_NUM] =</div><div class="line">    {{.<a class="code" href="struct_m_c_a_n___ext_msg_i_d_filter_element.html#ad54a2595a9ea5869b8662927fc3e8123">efid1</a> = 0x1234578, .efid2 = 0x1234600, .efec = <a class="code" href="group___c_a_n___f_e_c.html#ga88a35c0e4eb09d0f42637309a9f41621">CAN_FEC_STORE_RXFIFO1</a>, .eft = <a class="code" href="group___c_a_n___f_i_l_t_e_r___t_y_p_e.html#ga02fd3a61a95fd97242c3e2b3b37e15f5">CAN_FILTER_RANGE</a>}};</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="struct_c_a_n___msg_ram_config.html">CAN_MsgRamConfig</a> msgRamConfig = {</div><div class="line">    .<a class="code" href="struct_c_a_n___msg_ram_config.html#ac6d266db26fa4627eba2d02577e87c3f">stdFilterNum</a>       = STD_MSG_FILTER_NUM,</div><div class="line">    .extFilterNum       = EXT_MSG_FILTER_NUM,</div><div class="line">    .stdMsgIDFilterList = &amp;stdMsgIDFilter[0],</div><div class="line">    .extMsgIDFilterList = &amp;extMsgIDFilter[0],</div><div class="line"></div><div class="line">    .rxFifoNum[0] = 10U,</div><div class="line">    .rxFifoNum[1] = 2U,</div><div class="line">    .rxBufNum     = 1U,</div><div class="line">    .txBufNum     = 1U,</div><div class="line">    .txFifoQNum   = 5U,</div><div class="line">    .txFifoQMode  = 1U,</div><div class="line">};</div><div class="line"></div><div class="line">int_fast16_t status;</div><div class="line"></div><div class="line"><span class="comment">// Initialize driver(s).</span></div><div class="line"><a class="code" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31">CAN_init</a>();</div><div class="line"></div><div class="line"><span class="comment">// Open CAN driver with custom message filters.</span></div><div class="line"><a class="code" href="_c_a_n_8h.html#a9a7a7042e4948d4e04b9cb5205c50acf">CAN_Params_init</a>(&amp;canParams);</div><div class="line">canParams.msgRamConfig = &amp;msgRamConfig;</div><div class="line">canParams.eventCbk  = eventCallback;</div><div class="line"><span class="comment">// Setup event mask for events the application is interested in receiving</span></div><div class="line"><span class="comment">// the callback for. Typically, only the CAN_EVENT_RX_DATA_AVAIL is required.</span></div><div class="line">canParams.eventMask = <a class="code" href="group___c_a_n___e_v_e_n_t.html#ga7b6db1c1518135c8d1631a961ceb6e47">CAN_EVENT_RX_DATA_AVAIL</a>;</div><div class="line"></div><div class="line">canHandle = <a class="code" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4">CAN_open</a>(CONFIG_CAN_0, &amp;canParams);</div><div class="line"><span class="keywordflow">if</span> (canHandle == NULL)</div><div class="line">{</div><div class="line">    <span class="comment">// CAN_open() failed.</span></div><div class="line">    <span class="keywordflow">while</span> (1) {}</div><div class="line">}</div></div><!-- fragment --><p><a class="anchor" id="ti_drivers_CAN_Example_initRawBitRate"></a> Example initializing the CAN driver with a specific raw bit rate timing: </p><dl class="section note"><dt>Note</dt><dd>For this example, CAN driver SysConfig should be setup with 'CAN FD Operation' and 'Bit Rate Switching' enabled. The nominal and data bit rates selected in SysConfig will be ignored since raw bit rate timing parameters are provided to <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a>.</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="struct_c_a_n___data_bit_rate_timing_raw.html">CAN_DataBitRateTimingRaw</a> rawDataBitRateTiming = {</div><div class="line">    <span class="comment">// 1Mbps with 40MHz clk and 80% sample point ((40E6 / 2) / (15 + 4 + 1) = 1E6)</span></div><div class="line">    <span class="comment">// Add 1 to each programmed bit time to get functional value and +1 for for prop segment</span></div><div class="line">    .<a class="code" href="struct_c_a_n___data_bit_rate_timing_raw.html#ae6a44ddc44286ab32df97b7c4a0b8a80">dbrp</a>            = 1U,</div><div class="line">    .dtSeg1          = 14U,</div><div class="line">    .dtSeg2          = 3U,</div><div class="line">    .dsjw            = 3U,</div><div class="line">    .tdcOffset       = 14U,</div><div class="line">    .tdcFilterWinLen = 0U</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="struct_c_a_n___bit_rate_timing_raw.html">CAN_BitRateTimingRaw</a> rawBitTiming = {</div><div class="line">    <span class="comment">// 500kbps nominal with 40MHz clk and 87.5% sample point ((40E6 / 1) / (69 + 10 + 1) = 500E3)</span></div><div class="line">    <span class="comment">// Add 1 to each programmed bit time to get functional value and +1 for for prop segment</span></div><div class="line">    .<a class="code" href="struct_c_a_n___bit_rate_timing_raw.html#a203d950ef871c3f4b0cd4bbda8c55d43">nbrp</a>       = 0U,</div><div class="line">    .ntSeg1     = 68U,</div><div class="line">    .ntSeg2     = 9U,</div><div class="line">    .nsjw       = 9U,</div><div class="line">    .dataTiming = &amp;rawDataBitRateTiming</div><div class="line">};</div><div class="line"></div><div class="line">int_fast16_t status;</div><div class="line"></div><div class="line"><span class="comment">// Initialize driver(s).</span></div><div class="line"><a class="code" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31">CAN_init</a>();</div><div class="line"></div><div class="line"><span class="comment">// Open CAN with specific raw bit timing.</span></div><div class="line"><a class="code" href="_c_a_n_8h.html#a9a7a7042e4948d4e04b9cb5205c50acf">CAN_Params_init</a>(&amp;canParams);</div><div class="line">canParams.bitTiming = &amp;rawBitTiming;</div><div class="line">canParams.eventCbk  = eventCallback;</div><div class="line"><span class="comment">// Setup event mask for events the application is interested in receiving</span></div><div class="line"><span class="comment">// the callback for. Typically, only the CAN_EVENT_RX_DATA_AVAIL is required.</span></div><div class="line">canParams.eventMask = <a class="code" href="group___c_a_n___e_v_e_n_t.html#ga7b6db1c1518135c8d1631a961ceb6e47">CAN_EVENT_RX_DATA_AVAIL</a>;</div><div class="line"></div><div class="line">canHandle = <a class="code" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4">CAN_open</a>(CONFIG_CAN_0, &amp;canParams);</div><div class="line"><span class="keywordflow">if</span> (canHandle == NULL)</div><div class="line">{</div><div class="line">    <span class="comment">// CAN_open() failed.</span></div><div class="line">    <span class="keywordflow">while</span> (1) {}</div><div class="line">}</div></div><!-- fragment --><h2>CAN Message RAM Configuration</h2>
<p>The default message RAM configuration is as follows:</p><ul>
<li>No Rx filters.</li>
<li>Tx Queue (message with lowest ID in the queue will be transmitted first) with a fixed device-specific number of Tx buffers.</li>
<li>No Tx event FIFO.</li>
<li>Fixed device-specific number of Rx FIFO0 buffers.</li>
<li>No Rx FIFO1 buffers.</li>
<li>No dedicated Rx buffers.</li>
</ul>
<p>The number of default Tx and Rx buffers varies depending on the size of the device's message RAM. Check the doxygen for the device-specific CAN implementation to find the message RAM size. If using a custom message RAM configuration, utilize the entire space by maximizing the number of Rx/Tx buffers for optimal performance.</p>
<h2>CAN Write Behavior</h2>
<p><a class="el" href="_c_a_n_8h.html#ab670eb9a60e4f12c2eab6df7c2fa87e5" title="Sends CAN message using the Tx FIFO/Queue. ">CAN_write()</a> will return immediately after the message is loaded into the CAN controller's message RAM and pending transfer; it does not wait for the CAN message to be transmitted on the bus before returning. The CAN controller will automatically handle transmission retries in the event of a failure.</p>
<h2>CAN Read Behavior</h2>
<p>When a message is received in Rx FIFO0/1 or a dedicated Rx buffer, the CAN driver's IRQ handler automatically reads the Rx buffer element from the CAN controller's message RAM and stores it in a ring buffer whose size is configurable in SysConfig. When <a class="el" href="_c_a_n_8h.html#a515269a858d44d1ed043ccd37f3eedcb" title="Reads a received CAN message. ">CAN_read()</a> is called, the Rx buffer element is copied from the ring buffer to the application. If the ring buffer becomes full, any new messages received will be lost until the application frees space in the ring buffer by calling <a class="el" href="_c_a_n_8h.html#a515269a858d44d1ed043ccd37f3eedcb" title="Reads a received CAN message. ">CAN_read()</a>. </p>
</div><div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;<a class="el" href="_struct_ring_buf_8h_source.html">ti/drivers/utils/StructRingBuf.h</a>&gt;</code><br />
<code>#include &lt;ti/devices/DeviceFamily.h&gt;</code><br />
<code>#include &lt;<a class="el" href="_m_c_a_n_8h_source.html">third_party/mcan/MCAN.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for CAN.h:</div>
<div class="dyncontent">
<div class="center"><img src="_c_a_n_8h__incl.png" border="0" usemap="#_c_a_n_8h" alt=""/></div>
<map name="_c_a_n_8h" id="_c_a_n_8h">
<area shape="rect" id="node4" href="_struct_ring_buf_8h.html" title="ti/drivers/utils/StructRing\lBuf.h" alt="" coords="343,80,525,121"/>
<area shape="rect" id="node8" href="_m_c_a_n_8h.html" title="Hardware abstraction layer for M_CAN Controller v3.2.1. " alt="" coords="78,87,267,114"/>
<area shape="rect" id="node9" href="_m_c_a_n__reg_8h.html" title="M_CAN controller v3.2.1 register definitions. " alt="" coords="100,169,256,211"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="_c_a_n_8h__dep__incl.png" border="0" usemap="#_c_a_n_8hdep" alt=""/></div>
<map name="_c_a_n_8hdep" id="_c_a_n_8hdep">
<area shape="rect" id="node2" href="_c_a_n_m_c_a_n_8h.html" title="Common CAN functions for MCAN configuration. " alt="" coords="5,80,108,107"/>
</map>
</div>
</div>
<p><a href="_c_a_n_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_a_n___msg_ram_config.html">CAN_MsgRamConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN Message RAM configuration.  <a href="struct_c_a_n___msg_ram_config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_a_n___data_bit_rate_timing_raw.html">CAN_DataBitRateTimingRaw</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure defining the raw MCAN CAN FD data phase bit rate configuration.  <a href="struct_c_a_n___data_bit_rate_timing_raw.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_a_n___bit_rate_timing_raw.html">CAN_BitRateTimingRaw</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure defining the raw MCAN bit rate configuration.  <a href="struct_c_a_n___bit_rate_timing_raw.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_a_n___params.html">CAN_Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN Parameters.  <a href="struct_c_a_n___params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_a_n___object.html">CAN_Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN Object.  <a href="struct_c_a_n___object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_a_n___h_w_attrs.html">CAN_HWAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN hardware attributes.  <a href="struct_c_a_n___h_w_attrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_c_a_n___config__.html">CAN_Config_</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN Global configuration.  <a href="struct_c_a_n___config__.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gaec519b2472a0cb3c778a1e2cffd7de5d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___s_t_a_t_u_s.html#gaec519b2472a0cb3c778a1e2cffd7de5d">CAN_STATUS_SUCCESS</a>&#160;&#160;&#160;((int_fast16_t)0)</td></tr>
<tr class="memdesc:gaec519b2472a0cb3c778a1e2cffd7de5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Successful status code.  <a href="group___c_a_n___s_t_a_t_u_s.html#gaec519b2472a0cb3c778a1e2cffd7de5d">More...</a><br /></td></tr>
<tr class="separator:gaec519b2472a0cb3c778a1e2cffd7de5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf97bc85f9b1ce1bd427ab76347994217"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___s_t_a_t_u_s.html#gaf97bc85f9b1ce1bd427ab76347994217">CAN_STATUS_ERROR</a>&#160;&#160;&#160;((int_fast16_t)-1)</td></tr>
<tr class="memdesc:gaf97bc85f9b1ce1bd427ab76347994217"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic error status code.  <a href="group___c_a_n___s_t_a_t_u_s.html#gaf97bc85f9b1ce1bd427ab76347994217">More...</a><br /></td></tr>
<tr class="separator:gaf97bc85f9b1ce1bd427ab76347994217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03e296bed4b1621253ec798624282c52"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___s_t_a_t_u_s.html#ga03e296bed4b1621253ec798624282c52">CAN_STATUS_NOT_SUPPORTED</a>&#160;&#160;&#160;((int_fast16_t)-2)</td></tr>
<tr class="memdesc:ga03e296bed4b1621253ec798624282c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Not supported status code.  <a href="group___c_a_n___s_t_a_t_u_s.html#ga03e296bed4b1621253ec798624282c52">More...</a><br /></td></tr>
<tr class="separator:ga03e296bed4b1621253ec798624282c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabb3a4c95249453a5277851bdaeb4dc94"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___s_t_a_t_u_s.html#gabb3a4c95249453a5277851bdaeb4dc94">CAN_STATUS_TX_BUF_FULL</a>&#160;&#160;&#160;((int_fast16_t)-3)</td></tr>
<tr class="memdesc:gabb3a4c95249453a5277851bdaeb4dc94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tx buffer full status code.  <a href="group___c_a_n___s_t_a_t_u_s.html#gabb3a4c95249453a5277851bdaeb4dc94">More...</a><br /></td></tr>
<tr class="separator:gabb3a4c95249453a5277851bdaeb4dc94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00aea7977da7791f2828a61329b6ca62"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___s_t_a_t_u_s.html#ga00aea7977da7791f2828a61329b6ca62">CAN_STATUS_NO_RX_MSG_AVAIL</a>&#160;&#160;&#160;((int_fast16_t)-4)</td></tr>
<tr class="memdesc:ga00aea7977da7791f2828a61329b6ca62"><td class="mdescLeft">&#160;</td><td class="mdescRight">No received message available status code.  <a href="group___c_a_n___s_t_a_t_u_s.html#ga00aea7977da7791f2828a61329b6ca62">More...</a><br /></td></tr>
<tr class="separator:ga00aea7977da7791f2828a61329b6ca62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc760edfc496bb0c17a37dea54039e3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___s_t_a_t_u_s.html#gadc760edfc496bb0c17a37dea54039e3f">CAN_STATUS_NO_TX_EVENT_AVAIL</a>&#160;&#160;&#160;((int_fast16_t)-5)</td></tr>
<tr class="memdesc:gadc760edfc496bb0c17a37dea54039e3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">No Tx event available status code.  <a href="group___c_a_n___s_t_a_t_u_s.html#gadc760edfc496bb0c17a37dea54039e3f">More...</a><br /></td></tr>
<tr class="separator:gadc760edfc496bb0c17a37dea54039e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5aee970eec46cc8a1cbc21be1c3da321"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___e_v_e_n_t.html#ga5aee970eec46cc8a1cbc21be1c3da321">CAN_EVENT_SPI_XFER_ERROR</a>&#160;&#160;&#160;(0x800U)</td></tr>
<tr class="memdesc:ga5aee970eec46cc8a1cbc21be1c3da321"><td class="mdescLeft">&#160;</td><td class="mdescRight">A SPI transfer error occurred.  <a href="group___c_a_n___e_v_e_n_t.html#ga5aee970eec46cc8a1cbc21be1c3da321">More...</a><br /></td></tr>
<tr class="separator:ga5aee970eec46cc8a1cbc21be1c3da321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga792207c71ee25d47ec1550e7dcaf5ab7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___e_v_e_n_t.html#ga792207c71ee25d47ec1550e7dcaf5ab7">CAN_EVENT_BIT_ERR_UNCORRECTED</a>&#160;&#160;&#160;(0x400U)</td></tr>
<tr class="memdesc:ga792207c71ee25d47ec1550e7dcaf5ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">An uncorrected bit error occurred.  <a href="group___c_a_n___e_v_e_n_t.html#ga792207c71ee25d47ec1550e7dcaf5ab7">More...</a><br /></td></tr>
<tr class="separator:ga792207c71ee25d47ec1550e7dcaf5ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b23e75721cbe2be44c31d4b32d0f6a1"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___e_v_e_n_t.html#ga6b23e75721cbe2be44c31d4b32d0f6a1">CAN_EVENT_RX_RING_BUFFER_FULL</a>&#160;&#160;&#160;(0x200U)</td></tr>
<tr class="memdesc:ga6b23e75721cbe2be44c31d4b32d0f6a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The driver's Rx ring buffer was full.  <a href="group___c_a_n___e_v_e_n_t.html#ga6b23e75721cbe2be44c31d4b32d0f6a1">More...</a><br /></td></tr>
<tr class="separator:ga6b23e75721cbe2be44c31d4b32d0f6a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9bad54e02a163b9335e16dbdc6776b7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___e_v_e_n_t.html#gad9bad54e02a163b9335e16dbdc6776b7">CAN_EVENT_RX_FIFO_MSG_LOST</a>&#160;&#160;&#160;(0x100U)</td></tr>
<tr class="memdesc:gad9bad54e02a163b9335e16dbdc6776b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A message was lost for hardware Rx FIFO.  <a href="group___c_a_n___e_v_e_n_t.html#gad9bad54e02a163b9335e16dbdc6776b7">More...</a><br /></td></tr>
<tr class="separator:gad9bad54e02a163b9335e16dbdc6776b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4f75d571122632b29b34266118df5e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___e_v_e_n_t.html#gaf4f75d571122632b29b34266118df5e2">CAN_EVENT_ERR_PASSIVE</a>&#160;&#160;&#160;(0x80U)</td></tr>
<tr class="memdesc:gaf4f75d571122632b29b34266118df5e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">State change to error passive.  <a href="group___c_a_n___e_v_e_n_t.html#gaf4f75d571122632b29b34266118df5e2">More...</a><br /></td></tr>
<tr class="separator:gaf4f75d571122632b29b34266118df5e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9d5b4622bdc27d5a89bff6352ef7c48d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___e_v_e_n_t.html#ga9d5b4622bdc27d5a89bff6352ef7c48d">CAN_EVENT_ERR_ACTIVE</a>&#160;&#160;&#160;(0x40U)</td></tr>
<tr class="memdesc:ga9d5b4622bdc27d5a89bff6352ef7c48d"><td class="mdescLeft">&#160;</td><td class="mdescRight">State change to error active.  <a href="group___c_a_n___e_v_e_n_t.html#ga9d5b4622bdc27d5a89bff6352ef7c48d">More...</a><br /></td></tr>
<tr class="separator:ga9d5b4622bdc27d5a89bff6352ef7c48d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8e5b6dc28c6ca51a811b88c2b9fad496"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___e_v_e_n_t.html#ga8e5b6dc28c6ca51a811b88c2b9fad496">CAN_EVENT_BUS_OFF</a>&#160;&#160;&#160;(0x20U)</td></tr>
<tr class="memdesc:ga8e5b6dc28c6ca51a811b88c2b9fad496"><td class="mdescLeft">&#160;</td><td class="mdescRight">State change to bus off.  <a href="group___c_a_n___e_v_e_n_t.html#ga8e5b6dc28c6ca51a811b88c2b9fad496">More...</a><br /></td></tr>
<tr class="separator:ga8e5b6dc28c6ca51a811b88c2b9fad496"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada6d79a9a3439bc1e19ead78bb15f719"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___e_v_e_n_t.html#gada6d79a9a3439bc1e19ead78bb15f719">CAN_EVENT_BUS_ON</a>&#160;&#160;&#160;(0x10U)</td></tr>
<tr class="memdesc:gada6d79a9a3439bc1e19ead78bb15f719"><td class="mdescLeft">&#160;</td><td class="mdescRight">State change to bus on.  <a href="group___c_a_n___e_v_e_n_t.html#gada6d79a9a3439bc1e19ead78bb15f719">More...</a><br /></td></tr>
<tr class="separator:gada6d79a9a3439bc1e19ead78bb15f719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab82008e494c5fc6c4811170e000f15ac"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___e_v_e_n_t.html#gab82008e494c5fc6c4811170e000f15ac">CAN_EVENT_TX_EVENT_LOST</a>&#160;&#160;&#160;(0x08U)</td></tr>
<tr class="memdesc:gab82008e494c5fc6c4811170e000f15ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CAN message transmission event was lost.  <a href="group___c_a_n___e_v_e_n_t.html#gab82008e494c5fc6c4811170e000f15ac">More...</a><br /></td></tr>
<tr class="separator:gab82008e494c5fc6c4811170e000f15ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga773b3d0a875e164686fa3ba89d575725"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___e_v_e_n_t.html#ga773b3d0a875e164686fa3ba89d575725">CAN_EVENT_TX_EVENT_AVAIL</a>&#160;&#160;&#160;(0x04U)</td></tr>
<tr class="memdesc:ga773b3d0a875e164686fa3ba89d575725"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CAN message transmission event is available.  <a href="group___c_a_n___e_v_e_n_t.html#ga773b3d0a875e164686fa3ba89d575725">More...</a><br /></td></tr>
<tr class="separator:ga773b3d0a875e164686fa3ba89d575725"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga108a81cd6b5bbb73c81080f429c3a867"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___e_v_e_n_t.html#ga108a81cd6b5bbb73c81080f429c3a867">CAN_EVENT_TX_FINISHED</a>&#160;&#160;&#160;(0x02U)</td></tr>
<tr class="memdesc:ga108a81cd6b5bbb73c81080f429c3a867"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CAN message transmission was completed.  <a href="group___c_a_n___e_v_e_n_t.html#ga108a81cd6b5bbb73c81080f429c3a867">More...</a><br /></td></tr>
<tr class="separator:ga108a81cd6b5bbb73c81080f429c3a867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b6db1c1518135c8d1631a961ceb6e47"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___e_v_e_n_t.html#ga7b6db1c1518135c8d1631a961ceb6e47">CAN_EVENT_RX_DATA_AVAIL</a>&#160;&#160;&#160;(0x01U)</td></tr>
<tr class="memdesc:ga7b6db1c1518135c8d1631a961ceb6e47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Received CAN message data is available.  <a href="group___c_a_n___e_v_e_n_t.html#ga7b6db1c1518135c8d1631a961ceb6e47">More...</a><br /></td></tr>
<tr class="separator:ga7b6db1c1518135c8d1631a961ceb6e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga052e53fa79e9316c88231e17229fba19"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#ga052e53fa79e9316c88231e17229fba19">CAN_DLC_0B</a>&#160;&#160;&#160;((uint32_t)0U)</td></tr>
<tr class="separator:ga052e53fa79e9316c88231e17229fba19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4140dcfdb86d89a391d5acf8eb05b911"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#ga4140dcfdb86d89a391d5acf8eb05b911">CAN_DLC_1B</a>&#160;&#160;&#160;((uint32_t)1U)</td></tr>
<tr class="separator:ga4140dcfdb86d89a391d5acf8eb05b911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga261587f2747d0c28d634e78e4c03e3a6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#ga261587f2747d0c28d634e78e4c03e3a6">CAN_DLC_2B</a>&#160;&#160;&#160;((uint32_t)2U)</td></tr>
<tr class="separator:ga261587f2747d0c28d634e78e4c03e3a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga73362aae3c14f34f6c04fa00b8587bfc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#ga73362aae3c14f34f6c04fa00b8587bfc">CAN_DLC_3B</a>&#160;&#160;&#160;((uint32_t)3U)</td></tr>
<tr class="separator:ga73362aae3c14f34f6c04fa00b8587bfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga111f3f02b68d9307d7afb69a6fef1fbf"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#ga111f3f02b68d9307d7afb69a6fef1fbf">CAN_DLC_4B</a>&#160;&#160;&#160;((uint32_t)4U)</td></tr>
<tr class="separator:ga111f3f02b68d9307d7afb69a6fef1fbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7d271cf9799472051e80008380662efd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#ga7d271cf9799472051e80008380662efd">CAN_DLC_5B</a>&#160;&#160;&#160;((uint32_t)5U)</td></tr>
<tr class="separator:ga7d271cf9799472051e80008380662efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff8ef8a309506b53c203151f003d77ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#gaff8ef8a309506b53c203151f003d77ef">CAN_DLC_6B</a>&#160;&#160;&#160;((uint32_t)6U)</td></tr>
<tr class="separator:gaff8ef8a309506b53c203151f003d77ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga162fdb43ae966193f8a765c5fd6d798d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#ga162fdb43ae966193f8a765c5fd6d798d">CAN_DLC_7B</a>&#160;&#160;&#160;((uint32_t)7U)</td></tr>
<tr class="separator:ga162fdb43ae966193f8a765c5fd6d798d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b025ba8a7f17e9c77a1efbd8ca240d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#ga1b025ba8a7f17e9c77a1efbd8ca240d8">CAN_DLC_8B</a>&#160;&#160;&#160;((uint32_t)8U)</td></tr>
<tr class="separator:ga1b025ba8a7f17e9c77a1efbd8ca240d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1062f460db0fe000a315d56df5e33bcb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#ga1062f460db0fe000a315d56df5e33bcb">CAN_DLC_12B</a>&#160;&#160;&#160;((uint32_t)9U)</td></tr>
<tr class="separator:ga1062f460db0fe000a315d56df5e33bcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32409cb6c9d015b3ecae524a290a20ee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#ga32409cb6c9d015b3ecae524a290a20ee">CAN_DLC_16B</a>&#160;&#160;&#160;((uint32_t)10U)</td></tr>
<tr class="separator:ga32409cb6c9d015b3ecae524a290a20ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3f2237d2c78d31ee6fa3b50b22ba97d5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#ga3f2237d2c78d31ee6fa3b50b22ba97d5">CAN_DLC_20B</a>&#160;&#160;&#160;((uint32_t)11U)</td></tr>
<tr class="separator:ga3f2237d2c78d31ee6fa3b50b22ba97d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac6cbf524106c85bc00b90fc173c573b5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#gac6cbf524106c85bc00b90fc173c573b5">CAN_DLC_24B</a>&#160;&#160;&#160;((uint32_t)12U)</td></tr>
<tr class="separator:gac6cbf524106c85bc00b90fc173c573b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5bbd2f4663e83765033ce0691ab137f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#gae5bbd2f4663e83765033ce0691ab137f">CAN_DLC_32B</a>&#160;&#160;&#160;((uint32_t)13U)</td></tr>
<tr class="separator:gae5bbd2f4663e83765033ce0691ab137f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373898d8122525b9e35a84dcca58abee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#ga373898d8122525b9e35a84dcca58abee">CAN_DLC_48B</a>&#160;&#160;&#160;((uint32_t)14U)</td></tr>
<tr class="separator:ga373898d8122525b9e35a84dcca58abee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36d05d20d54c1602c8f53b23dd12b842"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___d_l_c.html#ga36d05d20d54c1602c8f53b23dd12b842">CAN_DLC_64B</a>&#160;&#160;&#160;((uint32_t)15U)</td></tr>
<tr class="separator:ga36d05d20d54c1602c8f53b23dd12b842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae76fdd5aaef8272b3a395ff173b7de6c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___f_e_c.html#gae76fdd5aaef8272b3a395ff173b7de6c">CAN_FEC_DISABLE_FILTER</a>&#160;&#160;&#160;((uint32_t)0U)</td></tr>
<tr class="separator:gae76fdd5aaef8272b3a395ff173b7de6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8a4569aef9c12b6f3cfc7bacc4573b2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___f_e_c.html#gae8a4569aef9c12b6f3cfc7bacc4573b2">CAN_FEC_STORE_RXFIFO0</a>&#160;&#160;&#160;((uint32_t)1U)</td></tr>
<tr class="separator:gae8a4569aef9c12b6f3cfc7bacc4573b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88a35c0e4eb09d0f42637309a9f41621"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___f_e_c.html#ga88a35c0e4eb09d0f42637309a9f41621">CAN_FEC_STORE_RXFIFO1</a>&#160;&#160;&#160;((uint32_t)2U)</td></tr>
<tr class="separator:ga88a35c0e4eb09d0f42637309a9f41621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15e3e16d185de52c0093fa49c09b43fb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___f_e_c.html#ga15e3e16d185de52c0093fa49c09b43fb">CAN_FEC_REJECT_ID</a>&#160;&#160;&#160;((uint32_t)3U)</td></tr>
<tr class="separator:ga15e3e16d185de52c0093fa49c09b43fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe90bce702d871dfe3c638e96951b658"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___f_e_c.html#gafe90bce702d871dfe3c638e96951b658">CAN_FEC_SET_PRIO</a>&#160;&#160;&#160;((uint32_t)4U)</td></tr>
<tr class="separator:gafe90bce702d871dfe3c638e96951b658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3bd065ccc4141b4d946988ccc82a010e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___f_e_c.html#ga3bd065ccc4141b4d946988ccc82a010e">CAN_FEC_SET_PRIO_STORE_RXFIFO0</a>&#160;&#160;&#160;((uint32_t)5U)</td></tr>
<tr class="separator:ga3bd065ccc4141b4d946988ccc82a010e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8aa1f099d70fe67c779f82c3bb1928be"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___f_e_c.html#ga8aa1f099d70fe67c779f82c3bb1928be">CAN_FEC_SET_PRIO_STORE_RXFIFO1</a>&#160;&#160;&#160;((uint32_t)6U)</td></tr>
<tr class="separator:ga8aa1f099d70fe67c779f82c3bb1928be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62ba101b4434f8b1169c4f6ca1fc6423"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___f_e_c.html#ga62ba101b4434f8b1169c4f6ca1fc6423">CAN_FEC_STORE_RXBUF</a>&#160;&#160;&#160;((uint32_t)7U)</td></tr>
<tr class="separator:ga62ba101b4434f8b1169c4f6ca1fc6423"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga02fd3a61a95fd97242c3e2b3b37e15f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___f_i_l_t_e_r___t_y_p_e.html#ga02fd3a61a95fd97242c3e2b3b37e15f5">CAN_FILTER_RANGE</a>&#160;&#160;&#160;((uint32_t)0U)</td></tr>
<tr class="separator:ga02fd3a61a95fd97242c3e2b3b37e15f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9661fdc40f3f402cd7d273105271303"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___f_i_l_t_e_r___t_y_p_e.html#gae9661fdc40f3f402cd7d273105271303">CAN_FILTER_DUAL_ID</a>&#160;&#160;&#160;((uint32_t)1U)</td></tr>
<tr class="separator:gae9661fdc40f3f402cd7d273105271303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf14edc6fbe8165c2dda302d136686028"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___f_i_l_t_e_r___t_y_p_e.html#gaf14edc6fbe8165c2dda302d136686028">CAN_FILTER_WITH_MASK</a>&#160;&#160;&#160;((uint32_t)2U)</td></tr>
<tr class="separator:gaf14edc6fbe8165c2dda302d136686028"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae5f65d2b17cf93b5f23eabfbf7be7bbc"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group___c_a_n___f_i_l_t_e_r___t_y_p_e.html#gae5f65d2b17cf93b5f23eabfbf7be7bbc">CAN_FILTER_DISABLE</a>&#160;&#160;&#160;((uint32_t)3U)</td></tr>
<tr class="separator:gae5f65d2b17cf93b5f23eabfbf7be7bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7d6743d2652302188c93f47db5dcfc45"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_m_c_a_n___rx_buf_element.html">MCAN_RxBufElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a7d6743d2652302188c93f47db5dcfc45">CAN_RxBufElement</a></td></tr>
<tr class="memdesc:a7d6743d2652302188c93f47db5dcfc45"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CAN Rx buffer element struct for <a class="el" href="_c_a_n_8h.html#a515269a858d44d1ed043ccd37f3eedcb" title="Reads a received CAN message. ">CAN_read()</a>.  <a href="#a7d6743d2652302188c93f47db5dcfc45">More...</a><br /></td></tr>
<tr class="separator:a7d6743d2652302188c93f47db5dcfc45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fa90475d917c858125b0556d79e4ca6"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_m_c_a_n___tx_buf_element.html">MCAN_TxBufElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a6fa90475d917c858125b0556d79e4ca6">CAN_TxBufElement</a></td></tr>
<tr class="memdesc:a6fa90475d917c858125b0556d79e4ca6"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CAN Tx buffer element struct for <a class="el" href="_c_a_n_8h.html#ab670eb9a60e4f12c2eab6df7c2fa87e5" title="Sends CAN message using the Tx FIFO/Queue. ">CAN_write()</a> and <a class="el" href="_c_a_n_8h.html#a5faff3ed36a87d3459a2870f4e622d25" title="Sends CAN message using a dedicated Tx Buffer. ">CAN_writeBuffer()</a>.  <a href="#a6fa90475d917c858125b0556d79e4ca6">More...</a><br /></td></tr>
<tr class="separator:a6fa90475d917c858125b0556d79e4ca6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8772b52f18edb856a269966c547f87dd"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_m_c_a_n___tx_event_fifo_element.html">MCAN_TxEventFifoElement</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a8772b52f18edb856a269966c547f87dd">CAN_TxEventElement</a></td></tr>
<tr class="memdesc:a8772b52f18edb856a269966c547f87dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CAN Tx Event element struct for <a class="el" href="_c_a_n_8h.html#a52e9349d952c4ab8ee874cf337ba61d5" title="Reads the next available CAN Tx Event FIFO element. ">CAN_readTxEvent()</a>.  <a href="#a8772b52f18edb856a269966c547f87dd">More...</a><br /></td></tr>
<tr class="separator:a8772b52f18edb856a269966c547f87dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aece4fe229807a6b7aa852376122f7bd2"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_m_c_a_n___bit_timing_params.html">MCAN_BitTimingParams</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#aece4fe229807a6b7aa852376122f7bd2">CAN_BitTimingParams</a></td></tr>
<tr class="memdesc:aece4fe229807a6b7aa852376122f7bd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">A CAN bit timing struct for <a class="el" href="_c_a_n_8h.html#a537b65f6cef1a7bf274e7550bb355d37" title="Get the CAN bit timings and functional clock frequency. ">CAN_getBitTiming()</a>.  <a href="#aece4fe229807a6b7aa852376122f7bd2">More...</a><br /></td></tr>
<tr class="separator:aece4fe229807a6b7aa852376122f7bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c6849a36f49970a418d45e72c9b516"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_c_a_n___config__.html">CAN_Config_</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a></td></tr>
<tr class="memdesc:a04c6849a36f49970a418d45e72c9b516"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle that is returned from a <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a> call.  <a href="#a04c6849a36f49970a418d45e72c9b516">More...</a><br /></td></tr>
<tr class="separator:a04c6849a36f49970a418d45e72c9b516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae049aa077771ab029cf97e6d9c17d136"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#ae049aa077771ab029cf97e6d9c17d136">CAN_EventCbk</a>) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, uint32_t event, uint32_t data, void *userArg)</td></tr>
<tr class="memdesc:ae049aa077771ab029cf97e6d9c17d136"><td class="mdescLeft">&#160;</td><td class="mdescRight">The definition of a callback function used by the CAN driver.  <a href="#ae049aa077771ab029cf97e6d9c17d136">More...</a><br /></td></tr>
<tr class="separator:ae049aa077771ab029cf97e6d9c17d136"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adcb3cde9a6e999f9434e4689a917b9"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_c_a_n___config__.html">CAN_Config_</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a2adcb3cde9a6e999f9434e4689a917b9">CAN_Config</a></td></tr>
<tr class="memdesc:a2adcb3cde9a6e999f9434e4689a917b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">CAN Global configuration.  <a href="#a2adcb3cde9a6e999f9434e4689a917b9">More...</a><br /></td></tr>
<tr class="separator:a2adcb3cde9a6e999f9434e4689a917b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ace7de72cc97ae2a35d63c3a4a4772a31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31">CAN_init</a> (void)</td></tr>
<tr class="memdesc:ace7de72cc97ae2a35d63c3a4a4772a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function initializes the CAN module.  <a href="#ace7de72cc97ae2a35d63c3a4a4772a31">More...</a><br /></td></tr>
<tr class="separator:ace7de72cc97ae2a35d63c3a4a4772a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a7a7042e4948d4e04b9cb5205c50acf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a9a7a7042e4948d4e04b9cb5205c50acf">CAN_Params_init</a> (<a class="el" href="struct_c_a_n___params.html">CAN_Params</a> *<a class="el" href="_driver___init_8h.html#af93f10d4f7393a01dff58c92f91d8cbc">params</a>)</td></tr>
<tr class="memdesc:a9a7a7042e4948d4e04b9cb5205c50acf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="struct_c_a_n___params.html" title="CAN Parameters. ">CAN_Params</a> struct to its default values.  <a href="#a9a7a7042e4948d4e04b9cb5205c50acf">More...</a><br /></td></tr>
<tr class="separator:a9a7a7042e4948d4e04b9cb5205c50acf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac007ed113727f16540e8b8e5d4e88fe4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4">CAN_open</a> (uint_least8_t index, <a class="el" href="struct_c_a_n___params.html">CAN_Params</a> *<a class="el" href="_driver___init_8h.html#af93f10d4f7393a01dff58c92f91d8cbc">params</a>)</td></tr>
<tr class="memdesc:ac007ed113727f16540e8b8e5d4e88fe4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a CAN driver instance and returns a handle.  <a href="#ac007ed113727f16540e8b8e5d4e88fe4">More...</a><br /></td></tr>
<tr class="separator:ac007ed113727f16540e8b8e5d4e88fe4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfc2ccd7bffde7724a17ab6c7e69f5cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#abfc2ccd7bffde7724a17ab6c7e69f5cf">CAN_close</a> (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle)</td></tr>
<tr class="memdesc:abfc2ccd7bffde7724a17ab6c7e69f5cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Closes a CAN peripheral specified by <em>handle</em>.  <a href="#abfc2ccd7bffde7724a17ab6c7e69f5cf">More...</a><br /></td></tr>
<tr class="separator:abfc2ccd7bffde7724a17ab6c7e69f5cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a515269a858d44d1ed043ccd37f3eedcb"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a515269a858d44d1ed043ccd37f3eedcb">CAN_read</a> (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, <a class="el" href="_c_a_n_8h.html#a7d6743d2652302188c93f47db5dcfc45">CAN_RxBufElement</a> *elem)</td></tr>
<tr class="memdesc:a515269a858d44d1ed043ccd37f3eedcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a received CAN message.  <a href="#a515269a858d44d1ed043ccd37f3eedcb">More...</a><br /></td></tr>
<tr class="separator:a515269a858d44d1ed043ccd37f3eedcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab670eb9a60e4f12c2eab6df7c2fa87e5"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#ab670eb9a60e4f12c2eab6df7c2fa87e5">CAN_write</a> (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, const <a class="el" href="_c_a_n_8h.html#a6fa90475d917c858125b0556d79e4ca6">CAN_TxBufElement</a> *elem)</td></tr>
<tr class="memdesc:ab670eb9a60e4f12c2eab6df7c2fa87e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends CAN message using the Tx FIFO/Queue.  <a href="#ab670eb9a60e4f12c2eab6df7c2fa87e5">More...</a><br /></td></tr>
<tr class="separator:ab670eb9a60e4f12c2eab6df7c2fa87e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5faff3ed36a87d3459a2870f4e622d25"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a5faff3ed36a87d3459a2870f4e622d25">CAN_writeBuffer</a> (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, uint32_t bufIdx, const <a class="el" href="_c_a_n_8h.html#a6fa90475d917c858125b0556d79e4ca6">CAN_TxBufElement</a> *elem)</td></tr>
<tr class="memdesc:a5faff3ed36a87d3459a2870f4e622d25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sends CAN message using a dedicated Tx Buffer.  <a href="#a5faff3ed36a87d3459a2870f4e622d25">More...</a><br /></td></tr>
<tr class="separator:a5faff3ed36a87d3459a2870f4e622d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e9349d952c4ab8ee874cf337ba61d5"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a52e9349d952c4ab8ee874cf337ba61d5">CAN_readTxEvent</a> (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, <a class="el" href="_c_a_n_8h.html#a8772b52f18edb856a269966c547f87dd">CAN_TxEventElement</a> *elem)</td></tr>
<tr class="memdesc:a52e9349d952c4ab8ee874cf337ba61d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads the next available CAN Tx Event FIFO element.  <a href="#a52e9349d952c4ab8ee874cf337ba61d5">More...</a><br /></td></tr>
<tr class="separator:a52e9349d952c4ab8ee874cf337ba61d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a537b65f6cef1a7bf274e7550bb355d37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a537b65f6cef1a7bf274e7550bb355d37">CAN_getBitTiming</a> (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, <a class="el" href="_c_a_n_8h.html#aece4fe229807a6b7aa852376122f7bd2">CAN_BitTimingParams</a> *bitTiming, uint32_t *clkFreq)</td></tr>
<tr class="memdesc:a537b65f6cef1a7bf274e7550bb355d37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the CAN bit timings and functional clock frequency.  <a href="#a537b65f6cef1a7bf274e7550bb355d37">More...</a><br /></td></tr>
<tr class="separator:a537b65f6cef1a7bf274e7550bb355d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4438793696220749713ccde080099b3d"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#a4438793696220749713ccde080099b3d">CAN_enableLoopbackExt</a> (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle)</td></tr>
<tr class="memdesc:a4438793696220749713ccde080099b3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables external loopback test mode.  <a href="#a4438793696220749713ccde080099b3d">More...</a><br /></td></tr>
<tr class="separator:a4438793696220749713ccde080099b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6206b975391c4b0e19b54097b12d785"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#ac6206b975391c4b0e19b54097b12d785">CAN_enableLoopbackInt</a> (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle)</td></tr>
<tr class="memdesc:ac6206b975391c4b0e19b54097b12d785"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables internal loopback test mode.  <a href="#ac6206b975391c4b0e19b54097b12d785">More...</a><br /></td></tr>
<tr class="separator:ac6206b975391c4b0e19b54097b12d785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9aa9243ed8fe0d17141bf56c94cffbf"><td class="memItemLeft" align="right" valign="top">int_fast16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#ac9aa9243ed8fe0d17141bf56c94cffbf">CAN_disableLoopback</a> (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle)</td></tr>
<tr class="memdesc:ac9aa9243ed8fe0d17141bf56c94cffbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disables loopback test mode.  <a href="#ac9aa9243ed8fe0d17141bf56c94cffbf">More...</a><br /></td></tr>
<tr class="separator:ac9aa9243ed8fe0d17141bf56c94cffbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ae353719375f08244685082e2a8440aad"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="_c_a_n_8h.html#a2adcb3cde9a6e999f9434e4689a917b9">CAN_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#ae353719375f08244685082e2a8440aad">CAN_config</a> []</td></tr>
<tr class="separator:ae353719375f08244685082e2a8440aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc4ab88f49cb2522ada61da8baced5d"><td class="memItemLeft" align="right" valign="top">const uint_least8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_c_a_n_8h.html#addc4ab88f49cb2522ada61da8baced5d">CAN_count</a></td></tr>
<tr class="separator:addc4ab88f49cb2522ada61da8baced5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a7d6743d2652302188c93f47db5dcfc45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6743d2652302188c93f47db5dcfc45">&sect;&nbsp;</a></span>CAN_RxBufElement</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_m_c_a_n___rx_buf_element.html">MCAN_RxBufElement</a> <a class="el" href="_c_a_n_8h.html#a7d6743d2652302188c93f47db5dcfc45">CAN_RxBufElement</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A CAN Rx buffer element struct for <a class="el" href="_c_a_n_8h.html#a515269a858d44d1ed043ccd37f3eedcb" title="Reads a received CAN message. ">CAN_read()</a>. </p>

</div>
</div>
<a id="a6fa90475d917c858125b0556d79e4ca6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fa90475d917c858125b0556d79e4ca6">&sect;&nbsp;</a></span>CAN_TxBufElement</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_m_c_a_n___tx_buf_element.html">MCAN_TxBufElement</a> <a class="el" href="_c_a_n_8h.html#a6fa90475d917c858125b0556d79e4ca6">CAN_TxBufElement</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A CAN Tx buffer element struct for <a class="el" href="_c_a_n_8h.html#ab670eb9a60e4f12c2eab6df7c2fa87e5" title="Sends CAN message using the Tx FIFO/Queue. ">CAN_write()</a> and <a class="el" href="_c_a_n_8h.html#a5faff3ed36a87d3459a2870f4e622d25" title="Sends CAN message using a dedicated Tx Buffer. ">CAN_writeBuffer()</a>. </p>

</div>
</div>
<a id="a8772b52f18edb856a269966c547f87dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8772b52f18edb856a269966c547f87dd">&sect;&nbsp;</a></span>CAN_TxEventElement</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_m_c_a_n___tx_event_fifo_element.html">MCAN_TxEventFifoElement</a> <a class="el" href="_c_a_n_8h.html#a8772b52f18edb856a269966c547f87dd">CAN_TxEventElement</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A CAN Tx Event element struct for <a class="el" href="_c_a_n_8h.html#a52e9349d952c4ab8ee874cf337ba61d5" title="Reads the next available CAN Tx Event FIFO element. ">CAN_readTxEvent()</a>. </p>

</div>
</div>
<a id="aece4fe229807a6b7aa852376122f7bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aece4fe229807a6b7aa852376122f7bd2">&sect;&nbsp;</a></span>CAN_BitTimingParams</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_m_c_a_n___bit_timing_params.html">MCAN_BitTimingParams</a> <a class="el" href="_c_a_n_8h.html#aece4fe229807a6b7aa852376122f7bd2">CAN_BitTimingParams</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A CAN bit timing struct for <a class="el" href="_c_a_n_8h.html#a537b65f6cef1a7bf274e7550bb355d37" title="Get the CAN bit timings and functional clock frequency. ">CAN_getBitTiming()</a>. </p>

</div>
</div>
<a id="a04c6849a36f49970a418d45e72c9b516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04c6849a36f49970a418d45e72c9b516">&sect;&nbsp;</a></span>CAN_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_c_a_n___config__.html">CAN_Config_</a>* <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle that is returned from a <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a> call. </p>

</div>
</div>
<a id="ae049aa077771ab029cf97e6d9c17d136"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae049aa077771ab029cf97e6d9c17d136">&sect;&nbsp;</a></span>CAN_EventCbk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* CAN_EventCbk) (<a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> handle, uint32_t event, uint32_t data, void *userArg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The definition of a callback function used by the CAN driver. </p>
<dl class="section note"><dt>Note</dt><dd>The callback can occur in task or interrupt context.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">handle</td><td>A <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a> returned from <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">event</td><td><a class="el" href="group___c_a_n___e_v_e_n_t.html">CAN events</a> that has occurred. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Data is event dependent:<ul>
<li><a class="el" href="group___c_a_n___e_v_e_n_t.html#ga7b6db1c1518135c8d1631a961ceb6e47" title="Received CAN message data is available. ">CAN_EVENT_RX_DATA_AVAIL</a>: number of Rx buffers available to read.</li>
<li><a class="el" href="group___c_a_n___e_v_e_n_t.html#gad9bad54e02a163b9335e16dbdc6776b7" title="A message was lost for hardware Rx FIFO. ">CAN_EVENT_RX_FIFO_MSG_LOST</a>: FIFO number.</li>
<li><a class="el" href="group___c_a_n___e_v_e_n_t.html#ga6b23e75721cbe2be44c31d4b32d0f6a1" title="The driver&#39;s Rx ring buffer was full. ">CAN_EVENT_RX_RING_BUFFER_FULL</a>: number of times the Rx ring buffer became full resulting in message loss.</li>
<li>CAN_EVENT_TX_FINISHED: mask of buffers for which transmission has occurred. Bits remain set until a new transmission is requested for the corresponding Tx buffer.</li>
<li>CAN_EVENT_TX_EVENT_AVAIL: the number of Tx Event elements currently available in the Tx Event FIFO.</li>
<li>CAN_EVENT_SPI_XFER_ERROR: SPI transfer status code.</li>
<li>other: unused </li>
</ul>
</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">userArg</td><td>A user supplied argument specified in <a class="el" href="struct_c_a_n___params.html" title="CAN Parameters. ">CAN_Params</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2adcb3cde9a6e999f9434e4689a917b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2adcb3cde9a6e999f9434e4689a917b9">&sect;&nbsp;</a></span>CAN_Config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_c_a_n___config__.html">CAN_Config_</a>  <a class="el" href="_c_a_n_8h.html#a2adcb3cde9a6e999f9434e4689a917b9">CAN_Config</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>CAN Global configuration. </p>
<p>The CAN_Config structure contains a set of pointers used to characterize the CAN driver implementation. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ace7de72cc97ae2a35d63c3a4a4772a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7de72cc97ae2a35d63c3a4a4772a31">&sect;&nbsp;</a></span>CAN_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function initializes the CAN module. </p>
<dl class="section pre"><dt>Precondition</dt><dd>The CAN_config structure must exist and be persistent before this function can be called. This function must also be called before any other CAN driver APIs. This function call does not modify any peripheral registers.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a> </dd></dl>

</div>
</div>
<a id="a9a7a7042e4948d4e04b9cb5205c50acf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a7a7042e4948d4e04b9cb5205c50acf">&sect;&nbsp;</a></span>CAN_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_c_a_n___params.html">CAN_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the <a class="el" href="struct_c_a_n___params.html" title="CAN Parameters. ">CAN_Params</a> struct to its default values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>An pointer to <a class="el" href="struct_c_a_n___params.html" title="CAN Parameters. ">CAN_Params</a> structure for initialization</td></tr>
  </table>
  </dd>
</dl>
<p>Defaults values are: msgRamConfig = NULL bitTiming = NULL tsPrescaler = 24U eventCbk = NULL eventMask = 0U userArg = NULL</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a> </dd></dl>

</div>
</div>
<a id="ac007ed113727f16540e8b8e5d4e88fe4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac007ed113727f16540e8b8e5d4e88fe4">&sect;&nbsp;</a></span>CAN_open()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a> CAN_open </td>
          <td>(</td>
          <td class="paramtype">uint_least8_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_c_a_n___params.html">CAN_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a CAN driver instance and returns a handle. </p>
<p>Initializes a CAN driver instance, configures the CAN device in normal operational mode, and returns a handle. Since the MCAN IP is highly configurable, the message RAM configuration and raw bit timings may be provided in the parameter block. Raw bit timings are required to use transmitter delay compensation. Invalid message RAM configuration or bit timing parameters will cause this function to fail.</p>
<dl class="section note"><dt>Note</dt><dd>For devices with an integrated CAN controller, a power contraint to prohibit standby will be set to allow the controller and its clock source to remain powered to receive CAN messages from the external transceiver. The power constrain will be released when <a class="el" href="_c_a_n_8h.html#abfc2ccd7bffde7724a17ab6c7e69f5cf" title="Closes a CAN peripheral specified by handle. ">CAN_close()</a> is called.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>CAN controller has been initialized using <a class="el" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31" title="This function initializes the CAN module. ">CAN_init()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">index</td><td>Logical peripheral number for the CAN indexed into the <a class="el" href="_c_a_n_8h.html#ae353719375f08244685082e2a8440aad">CAN_config</a> table </td></tr>
    <tr><td class="paramname">params</td><td>Pointer to a parameter block, if NULL it will use default values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a> on success, otherwise, NULL upon error or if it has been opened already.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31" title="This function initializes the CAN module. ">CAN_init()</a></dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_c_a_n_8h.html#abfc2ccd7bffde7724a17ab6c7e69f5cf" title="Closes a CAN peripheral specified by handle. ">CAN_close()</a> </dd></dl>

</div>
</div>
<a id="abfc2ccd7bffde7724a17ab6c7e69f5cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfc2ccd7bffde7724a17ab6c7e69f5cf">&sect;&nbsp;</a></span>CAN_close()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Closes a CAN peripheral specified by <em>handle</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a> returned from <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>None. </dd></dl>

</div>
</div>
<a id="a515269a858d44d1ed043ccd37f3eedcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a515269a858d44d1ed043ccd37f3eedcb">&sect;&nbsp;</a></span>CAN_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t CAN_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#a7d6743d2652302188c93f47db5dcfc45">CAN_RxBufElement</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads a received CAN message. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a> returned from <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a>. </td></tr>
    <tr><td class="paramname">elem</td><td>A pointer to a <a class="el" href="_c_a_n_8h.html#a7d6743d2652302188c93f47db5dcfc45" title="A CAN Rx buffer element struct for CAN_read(). ">CAN_RxBufElement</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAN_STATUS_SUCCESS</td><td>if successful. </td></tr>
    <tr><td class="paramname">CAN_STATUS_NO_RX_MSG_AVAIL</td><td>if no messages are available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab670eb9a60e4f12c2eab6df7c2fa87e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab670eb9a60e4f12c2eab6df7c2fa87e5">&sect;&nbsp;</a></span>CAN_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t CAN_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_c_a_n_8h.html#a6fa90475d917c858125b0556d79e4ca6">CAN_TxBufElement</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends CAN message using the Tx FIFO/Queue. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a> returned from <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a>. </td></tr>
    <tr><td class="paramname">elem</td><td>A pointer to a <a class="el" href="_c_a_n_8h.html#a6fa90475d917c858125b0556d79e4ca6" title="A CAN Tx buffer element struct for CAN_write() and CAN_writeBuffer(). ">CAN_TxBufElement</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAN_STATUS_SUCCESS</td><td>if successful. </td></tr>
    <tr><td class="paramname">CAN_STATUS_ERROR</td><td>if no Tx FIFO/Queue is configured. </td></tr>
    <tr><td class="paramname">CAN_STATUS_TX_BUF_FULL</td><td>if the Tx buffer is full. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5faff3ed36a87d3459a2870f4e622d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5faff3ed36a87d3459a2870f4e622d25">&sect;&nbsp;</a></span>CAN_writeBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t CAN_writeBuffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>bufIdx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="_c_a_n_8h.html#a6fa90475d917c858125b0556d79e4ca6">CAN_TxBufElement</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sends CAN message using a dedicated Tx Buffer. </p>
<p>Dedicated Tx buffers are intended for message transmission under complete control of the application. A custom message RAM config with dedicated Tx buffer(s) must be provided during <a class="el" href="_c_a_n_8h.html#ace7de72cc97ae2a35d63c3a4a4772a31" title="This function initializes the CAN module. ">CAN_init</a> in order to utilize this function.</p>
<dl class="section note"><dt>Note</dt><dd>The default message RAM configuration uses a Tx Queue in which the message with the highest priority in the queue is transmitted first. If a custom message RAM configuration with Tx FIFO is used, messages are transmitted out in the order they are placed in the FIFO. Adding a dedicated Tx buffer to the custom configuration and calling this function can allow a new higher priority message to be transmitted before the Tx FIFO is empty.</dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a> returned from <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a>. </td></tr>
    <tr><td class="paramname">bufIdx</td><td>Index of the dedicated Tx buffer. </td></tr>
    <tr><td class="paramname">elem</td><td>A pointer to a <a class="el" href="_c_a_n_8h.html#a6fa90475d917c858125b0556d79e4ca6" title="A CAN Tx buffer element struct for CAN_write() and CAN_writeBuffer(). ">CAN_TxBufElement</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAN_STATUS_SUCCESS</td><td>if successful. </td></tr>
    <tr><td class="paramname">CAN_STATUS_ERROR</td><td>if the Tx buffer index is invalid or the buffer already has a Tx request pending. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a52e9349d952c4ab8ee874cf337ba61d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e9349d952c4ab8ee874cf337ba61d5">&sect;&nbsp;</a></span>CAN_readTxEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t CAN_readTxEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#a8772b52f18edb856a269966c547f87dd">CAN_TxEventElement</a> *&#160;</td>
          <td class="paramname"><em>elem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads the next available CAN Tx Event FIFO element. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a> returned from <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a>. </td></tr>
    <tr><td class="paramname">elem</td><td>A pointer to a <a class="el" href="_c_a_n_8h.html#a8772b52f18edb856a269966c547f87dd" title="A CAN Tx Event element struct for CAN_readTxEvent(). ">CAN_TxEventElement</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAN_STATUS_SUCCESS</td><td>if successful. </td></tr>
    <tr><td class="paramname">CAN_STATUS_ERROR</td><td>if no Tx Event FIFO is configured. </td></tr>
    <tr><td class="paramname">CAN_STATUS_NO_TX_EVENT_AVAIL</td><td>if no Tx Event is available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a537b65f6cef1a7bf274e7550bb355d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a537b65f6cef1a7bf274e7550bb355d37">&sect;&nbsp;</a></span>CAN_getBitTiming()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CAN_getBitTiming </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#aece4fe229807a6b7aa852376122f7bd2">CAN_BitTimingParams</a> *&#160;</td>
          <td class="paramname"><em>bitTiming</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>clkFreq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the CAN bit timings and functional clock frequency. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a> has to be called first.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Add 1 to the bit timing values to obtain the functional values.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a> returned from <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a>. </td></tr>
    <tr><td class="paramname">bitTiming</td><td>A pointer to a <a class="el" href="_c_a_n_8h.html#aece4fe229807a6b7aa852376122f7bd2" title="A CAN bit timing struct for CAN_getBitTiming(). ">CAN_BitTimingParams</a> struct. </td></tr>
    <tr><td class="paramname">clkFreq</td><td>A pointer to the CAN functional clock frequency in kHz. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4438793696220749713ccde080099b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4438793696220749713ccde080099b3d">&sect;&nbsp;</a></span>CAN_enableLoopbackExt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t CAN_enableLoopbackExt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables external loopback test mode. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a> has to be called first.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a> returned from <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAN_STATUS_SUCCESS</td><td>if successful. </td></tr>
    <tr><td class="paramname">CAN_STATUS_NOT_SUPPORTED</td><td>if this feature is not supported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_c_a_n_8h.html#ac6206b975391c4b0e19b54097b12d785" title="Enables internal loopback test mode. ">CAN_enableLoopbackInt()</a> </dd>
<dd>
<a class="el" href="_c_a_n_8h.html#ac9aa9243ed8fe0d17141bf56c94cffbf" title="Disables loopback test mode. ">CAN_disableLoopback()</a> </dd></dl>

</div>
</div>
<a id="ac6206b975391c4b0e19b54097b12d785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6206b975391c4b0e19b54097b12d785">&sect;&nbsp;</a></span>CAN_enableLoopbackInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t CAN_enableLoopbackInt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables internal loopback test mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a> returned from <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a></dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAN_STATUS_SUCCESS</td><td>if successful. </td></tr>
    <tr><td class="paramname">CAN_STATUS_NOT_SUPPORTED</td><td>if this feature is not supported.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="_c_a_n_8h.html#a4438793696220749713ccde080099b3d" title="Enables external loopback test mode. ">CAN_enableLoopbackExt()</a> </dd>
<dd>
<a class="el" href="_c_a_n_8h.html#ac9aa9243ed8fe0d17141bf56c94cffbf" title="Disables loopback test mode. ">CAN_disableLoopback()</a> </dd></dl>

</div>
</div>
<a id="ac9aa9243ed8fe0d17141bf56c94cffbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9aa9243ed8fe0d17141bf56c94cffbf">&sect;&nbsp;</a></span>CAN_disableLoopback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int_fast16_t CAN_disableLoopback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516">CAN_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Disables loopback test mode. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a> has to be called first. </dd>
<dd>
<a class="el" href="_c_a_n_8h.html#a4438793696220749713ccde080099b3d" title="Enables external loopback test mode. ">CAN_enableLoopbackExt()</a> or <a class="el" href="_c_a_n_8h.html#ac6206b975391c4b0e19b54097b12d785" title="Enables internal loopback test mode. ">CAN_enableLoopbackInt()</a></dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A <a class="el" href="_c_a_n_8h.html#a04c6849a36f49970a418d45e72c9b516" title="A handle that is returned from a CAN_open() call. ">CAN_Handle</a> returned from <a class="el" href="_c_a_n_8h.html#ac007ed113727f16540e8b8e5d4e88fe4" title="Initializes a CAN driver instance and returns a handle. ">CAN_open()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">CAN_STATUS_SUCCESS</td><td>if successful. </td></tr>
    <tr><td class="paramname">CAN_STATUS_NOT_SUPPORTED</td><td>if this feature is not supported. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ae353719375f08244685082e2a8440aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae353719375f08244685082e2a8440aad">&sect;&nbsp;</a></span>CAN_config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="_c_a_n_8h.html#a2adcb3cde9a6e999f9434e4689a917b9">CAN_Config</a> CAN_config[]</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="addc4ab88f49cb2522ada61da8baced5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc4ab88f49cb2522ada61da8baced5d">&sect;&nbsp;</a></span>CAN_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint_least8_t CAN_count</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml"> Copyright 1995-2024</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
