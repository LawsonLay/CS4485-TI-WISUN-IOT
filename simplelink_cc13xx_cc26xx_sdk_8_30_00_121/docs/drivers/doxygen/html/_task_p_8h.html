<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>TaskP.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="dir_dd8fa7f0a423552d37651735ac37558f.html">ti</a></li><li class="navelem"><a class="el" href="dir_15fb9a92674a5e15cac1f3112cfb19ae.html">drivers</a></li><li class="navelem"><a class="el" href="dir_fb2953259385de282595b9f3b684779b.html">dpl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">TaskP.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Task module for the RTOS Porting Interface. </p>
<p>============================================================================</p>
<p>TaskP objects are RTOS threads backed by OS-specific thread or task objects. Task functions will run according to the rules of the underlying scheduler, with higher priority tasks executing first.</p>
<p>Tasks require a stack and a control struct to operate, which can either be allocated statically with TaskP_construct or dynamically with TaskP_create. The stack should be large enough to contain at least your deepest call stack plus an interrupt frame.</p>
<p>Task Functions: The void* argument will be NULL by default, but you can set a value using <a class="el" href="struct_task_p___params.html">TaskP_Params</a>. Task functions should never return, as the behaviour after a task has returned is implementation-dependent and TaskP does not provide a mechanism for OS-independent task deletion. See your OS documentation for </p><h1>details. </h1>
</div><div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for TaskP.h:</div>
<div class="dyncontent">
<div class="center"><img src="_task_p_8h__incl.png" border="0" usemap="#_task_p_8h" alt=""/></div>
<map name="_task_p_8h" id="_task_p_8h">
</map>
</div>
</div>
<p><a href="_task_p_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_task_p___struct.html">TaskP_Struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">TaskP structure.  <a href="union_task_p___struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_task_p___params.html">TaskP_Params</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aac2b2f55647e0f8cad9bed9043c701c7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_task_p_8h.html#aac2b2f55647e0f8cad9bed9043c701c7">TaskP_DEFAULT_STACK_SIZE</a>&#160;&#160;&#160;(512)</td></tr>
<tr class="memdesc:aac2b2f55647e0f8cad9bed9043c701c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes greater than or equal to the size of any RTOS Task object.  <a href="#aac2b2f55647e0f8cad9bed9043c701c7">More...</a><br /></td></tr>
<tr class="separator:aac2b2f55647e0f8cad9bed9043c701c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7445cf2d882fd19a0c2d8a16e026a915"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="union_task_p___struct.html">TaskP_Struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_task_p_8h.html#a7445cf2d882fd19a0c2d8a16e026a915">TaskP_Struct</a></td></tr>
<tr class="memdesc:a7445cf2d882fd19a0c2d8a16e026a915"><td class="mdescLeft">&#160;</td><td class="mdescRight">TaskP structure.  <a href="#a7445cf2d882fd19a0c2d8a16e026a915">More...</a><br /></td></tr>
<tr class="separator:a7445cf2d882fd19a0c2d8a16e026a915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ff8e662723e61efd85a4db30f89628"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="union_task_p___struct.html">TaskP_Struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_task_p_8h.html#a31ff8e662723e61efd85a4db30f89628">TaskP_Handle</a></td></tr>
<tr class="memdesc:a31ff8e662723e61efd85a4db30f89628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque client reference to an instance of a TaskP.  <a href="#a31ff8e662723e61efd85a4db30f89628">More...</a><br /></td></tr>
<tr class="separator:a31ff8e662723e61efd85a4db30f89628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0a57708d5950934830c66a8724fb6a5"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_task_p_8h.html#ac0a57708d5950934830c66a8724fb6a5">TaskP_Function</a>) (void *)</td></tr>
<tr class="memdesc:ac0a57708d5950934830c66a8724fb6a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task function definition, passed to create and construct.  <a href="#ac0a57708d5950934830c66a8724fb6a5">More...</a><br /></td></tr>
<tr class="separator:ac0a57708d5950934830c66a8724fb6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8f0482bc6ecdaabe28dff9e5d28198cd"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_task_p_8h.html#a8f0482bc6ecdaabe28dff9e5d28198cd">TaskP_State</a> { <br />
&#160;&#160;<a class="el" href="_task_p_8h.html#a8f0482bc6ecdaabe28dff9e5d28198cdaac0f03513caf43ced537f79595615df0">TaskP_State_RUNNING</a>, 
<a class="el" href="_task_p_8h.html#a8f0482bc6ecdaabe28dff9e5d28198cda9b2d5bf5d16c8db968e522a1006c992f">TaskP_State_READY</a>, 
<a class="el" href="_task_p_8h.html#a8f0482bc6ecdaabe28dff9e5d28198cda7ffb1e2a28c3657be3601cbf1fdca866">TaskP_State_BLOCKED</a>, 
<a class="el" href="_task_p_8h.html#a8f0482bc6ecdaabe28dff9e5d28198cdaaaf5a227c0828eeeda74ce6fc604a431">TaskP_State_DELETED</a>, 
<br />
&#160;&#160;<a class="el" href="_task_p_8h.html#a8f0482bc6ecdaabe28dff9e5d28198cda065d4dc283708f062245c94e46f3c869">TaskP_State_INACTIVE</a>, 
<a class="el" href="_task_p_8h.html#a8f0482bc6ecdaabe28dff9e5d28198cdaabea3e598d668c244f0cfa6a1f99c588">TaskP_State_INVALID</a>
<br />
 }<tr class="memdesc:a8f0482bc6ecdaabe28dff9e5d28198cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum returned from <a class="el" href="_task_p_8h.html#ab5ee6a6175e9dc75d3f47d635a9f2731" title="Get the current state of a task handle. ">TaskP_getState()</a>.  <a href="_task_p_8h.html#a8f0482bc6ecdaabe28dff9e5d28198cd">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8f0482bc6ecdaabe28dff9e5d28198cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4d8fda4ca1b5a3a7587b3232cf7bf43b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_task_p_8h.html#a31ff8e662723e61efd85a4db30f89628">TaskP_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_task_p_8h.html#a4d8fda4ca1b5a3a7587b3232cf7bf43b">TaskP_create</a> (<a class="el" href="_task_p_8h.html#ac0a57708d5950934830c66a8724fb6a5">TaskP_Function</a> fxn, const <a class="el" href="struct_task_p___params.html">TaskP_Params</a> *<a class="el" href="_driver___init_8h.html#af93f10d4f7393a01dff58c92f91d8cbc">params</a>)</td></tr>
<tr class="memdesc:a4d8fda4ca1b5a3a7587b3232cf7bf43b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a TaskP, allocating memory on the heap.  <a href="#a4d8fda4ca1b5a3a7587b3232cf7bf43b">More...</a><br /></td></tr>
<tr class="separator:a4d8fda4ca1b5a3a7587b3232cf7bf43b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ca78b4f2572ee6a2e04bff7f8892d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_task_p_8h.html#a88ca78b4f2572ee6a2e04bff7f8892d9">TaskP_delete</a> (<a class="el" href="_task_p_8h.html#a31ff8e662723e61efd85a4db30f89628">TaskP_Handle</a> task)</td></tr>
<tr class="memdesc:a88ca78b4f2572ee6a2e04bff7f8892d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a TaskP.  <a href="#a88ca78b4f2572ee6a2e04bff7f8892d9">More...</a><br /></td></tr>
<tr class="separator:a88ca78b4f2572ee6a2e04bff7f8892d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf938483764f419259c910b098b6fa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_task_p_8h.html#a31ff8e662723e61efd85a4db30f89628">TaskP_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_task_p_8h.html#a0bf938483764f419259c910b098b6fa4">TaskP_construct</a> (<a class="el" href="union_task_p___struct.html">TaskP_Struct</a> *obj, <a class="el" href="_task_p_8h.html#ac0a57708d5950934830c66a8724fb6a5">TaskP_Function</a> fxn, const <a class="el" href="struct_task_p___params.html">TaskP_Params</a> *<a class="el" href="_driver___init_8h.html#af93f10d4f7393a01dff58c92f91d8cbc">params</a>)</td></tr>
<tr class="memdesc:a0bf938483764f419259c910b098b6fa4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a TaskP from statically allocated memory.  <a href="#a0bf938483764f419259c910b098b6fa4">More...</a><br /></td></tr>
<tr class="separator:a0bf938483764f419259c910b098b6fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eacddcb7a8f8fbd37a08ea3b23b1c28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_task_p_8h.html#a2eacddcb7a8f8fbd37a08ea3b23b1c28">TaskP_destruct</a> (<a class="el" href="union_task_p___struct.html">TaskP_Struct</a> *obj)</td></tr>
<tr class="memdesc:a2eacddcb7a8f8fbd37a08ea3b23b1c28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destruct a TaskP.  <a href="#a2eacddcb7a8f8fbd37a08ea3b23b1c28">More...</a><br /></td></tr>
<tr class="separator:a2eacddcb7a8f8fbd37a08ea3b23b1c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ee6a6175e9dc75d3f47d635a9f2731"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_task_p_8h.html#a8f0482bc6ecdaabe28dff9e5d28198cd">TaskP_State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_task_p_8h.html#ab5ee6a6175e9dc75d3f47d635a9f2731">TaskP_getState</a> (<a class="el" href="_task_p_8h.html#a31ff8e662723e61efd85a4db30f89628">TaskP_Handle</a> task)</td></tr>
<tr class="memdesc:ab5ee6a6175e9dc75d3f47d635a9f2731"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current state of a task handle.  <a href="#ab5ee6a6175e9dc75d3f47d635a9f2731">More...</a><br /></td></tr>
<tr class="separator:ab5ee6a6175e9dc75d3f47d635a9f2731"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ad86c8971ad9ae9fd0f080b63bbb61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_task_p_8h.html#a31ff8e662723e61efd85a4db30f89628">TaskP_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_task_p_8h.html#a07ad86c8971ad9ae9fd0f080b63bbb61">TaskP_getCurrentTask</a> (void)</td></tr>
<tr class="memdesc:a07ad86c8971ad9ae9fd0f080b63bbb61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the currently executing task handle.  <a href="#a07ad86c8971ad9ae9fd0f080b63bbb61">More...</a><br /></td></tr>
<tr class="separator:a07ad86c8971ad9ae9fd0f080b63bbb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23392193f7f8b3be8458519949ce4763"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_task_p_8h.html#a23392193f7f8b3be8458519949ce4763">TaskP_disableScheduler</a> (void)</td></tr>
<tr class="memdesc:a23392193f7f8b3be8458519949ce4763"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to disable task scheduling.  <a href="#a23392193f7f8b3be8458519949ce4763">More...</a><br /></td></tr>
<tr class="separator:a23392193f7f8b3be8458519949ce4763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8c78742eec61d46ec4133cdee6f5ab4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_task_p_8h.html#ae8c78742eec61d46ec4133cdee6f5ab4">TaskP_restoreScheduler</a> (uintptr_t key)</td></tr>
<tr class="memdesc:ae8c78742eec61d46ec4133cdee6f5ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to re-enable task scheduling.  <a href="#ae8c78742eec61d46ec4133cdee6f5ab4">More...</a><br /></td></tr>
<tr class="separator:ae8c78742eec61d46ec4133cdee6f5ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f74bb9a6902f4c003d2f9f9a9c427a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_task_p_8h.html#a34f74bb9a6902f4c003d2f9f9a9c427a">TaskP_yield</a> (void)</td></tr>
<tr class="memdesc:a34f74bb9a6902f4c003d2f9f9a9c427a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a scheduler point, yielding to equal priority tasks.  <a href="#a34f74bb9a6902f4c003d2f9f9a9c427a">More...</a><br /></td></tr>
<tr class="separator:a34f74bb9a6902f4c003d2f9f9a9c427a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada126fc28d0aea5c60f1984dadfde56e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_task_p_8h.html#ada126fc28d0aea5c60f1984dadfde56e">TaskP_Params_init</a> (<a class="el" href="struct_task_p___params.html">TaskP_Params</a> *<a class="el" href="_driver___init_8h.html#af93f10d4f7393a01dff58c92f91d8cbc">params</a>)</td></tr>
<tr class="memdesc:ada126fc28d0aea5c60f1984dadfde56e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize params structure to default values.  <a href="#ada126fc28d0aea5c60f1984dadfde56e">More...</a><br /></td></tr>
<tr class="separator:ada126fc28d0aea5c60f1984dadfde56e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aac2b2f55647e0f8cad9bed9043c701c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2b2f55647e0f8cad9bed9043c701c7">&sect;&nbsp;</a></span>TaskP_DEFAULT_STACK_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TaskP_DEFAULT_STACK_SIZE&#160;&#160;&#160;(512)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bytes greater than or equal to the size of any RTOS Task object. </p>
<p>BIOS 6.x: 80 BIOS 7.x: 88 FreeRTOS: 104(llvm)/340(gcc)</p>
<p>Number of bytes for the default stack size of any RTOS Task object. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a7445cf2d882fd19a0c2d8a16e026a915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7445cf2d882fd19a0c2d8a16e026a915">&sect;&nbsp;</a></span>TaskP_Struct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="union_task_p___struct.html">TaskP_Struct</a>  <a class="el" href="union_task_p___struct.html">TaskP_Struct</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>TaskP structure. </p>
<p>Opaque structure that should be large enough to hold any of the RTOS specific TaskP objects. </p>

</div>
</div>
<a id="a31ff8e662723e61efd85a4db30f89628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ff8e662723e61efd85a4db30f89628">&sect;&nbsp;</a></span>TaskP_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="union_task_p___struct.html">TaskP_Struct</a>* <a class="el" href="_task_p_8h.html#a31ff8e662723e61efd85a4db30f89628">TaskP_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque client reference to an instance of a TaskP. </p>
<p>A TaskP_Handle returned from create or construct represents that instance. </p>

</div>
</div>
<a id="ac0a57708d5950934830c66a8724fb6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0a57708d5950934830c66a8724fb6a5">&sect;&nbsp;</a></span>TaskP_Function</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* TaskP_Function) (void *)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Task function definition, passed to create and construct. </p>
<p>This function should never return. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8f0482bc6ecdaabe28dff9e5d28198cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0482bc6ecdaabe28dff9e5d28198cd">&sect;&nbsp;</a></span>TaskP_State</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_task_p_8h.html#a8f0482bc6ecdaabe28dff9e5d28198cd">TaskP_State</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum returned from <a class="el" href="_task_p_8h.html#ab5ee6a6175e9dc75d3f47d635a9f2731" title="Get the current state of a task handle. ">TaskP_getState()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8f0482bc6ecdaabe28dff9e5d28198cdaac0f03513caf43ced537f79595615df0"></a>TaskP_State_RUNNING&#160;</td><td class="fielddoc"><p>This task is actively running </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f0482bc6ecdaabe28dff9e5d28198cda9b2d5bf5d16c8db968e522a1006c992f"></a>TaskP_State_READY&#160;</td><td class="fielddoc"><p>The task is ready to run, but not currently running </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f0482bc6ecdaabe28dff9e5d28198cda7ffb1e2a28c3657be3601cbf1fdca866"></a>TaskP_State_BLOCKED&#160;</td><td class="fielddoc"><p>The task is blocked </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f0482bc6ecdaabe28dff9e5d28198cdaaaf5a227c0828eeeda74ce6fc604a431"></a>TaskP_State_DELETED&#160;</td><td class="fielddoc"><p>The task has been deleted </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f0482bc6ecdaabe28dff9e5d28198cda065d4dc283708f062245c94e46f3c869"></a>TaskP_State_INACTIVE&#160;</td><td class="fielddoc"><p>The task is inactive </p>
</td></tr>
<tr><td class="fieldname"><a id="a8f0482bc6ecdaabe28dff9e5d28198cdaabea3e598d668c244f0cfa6a1f99c588"></a>TaskP_State_INVALID&#160;</td><td class="fielddoc"><p>The task is not found or in an otherwise invalid state </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a4d8fda4ca1b5a3a7587b3232cf7bf43b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8fda4ca1b5a3a7587b3232cf7bf43b">&sect;&nbsp;</a></span>TaskP_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_task_p_8h.html#a31ff8e662723e61efd85a4db30f89628">TaskP_Handle</a> TaskP_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_p_8h.html#ac0a57708d5950934830c66a8724fb6a5">TaskP_Function</a>&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_task_p___params.html">TaskP_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a TaskP, allocating memory on the heap. </p>
<p>Creates a new TaskP and registers it with the OS scheduler. The task object and the entire stack will be allocated on the heap - make sure you have a sufficiently large heap. Stack allocation size is controlled by params.</p>
<p>If the program is already executing a task and the new task has a higher priority the new task will be scheduled immediately; in this case <a class="el" href="_task_p_8h.html#a4d8fda4ca1b5a3a7587b3232cf7bf43b" title="Create a TaskP, allocating memory on the heap. ">TaskP_create()</a> will not return until the new task blocks. To avoid this (for example when creating interdependent tasks at once) use <a class="el" href="_task_p_8h.html#a23392193f7f8b3be8458519949ce4763" title="Function to disable task scheduling. ">TaskP_disableScheduler()</a> and <a class="el" href="_task_p_8h.html#ae8c78742eec61d46ec4133cdee6f5ab4" title="Function to re-enable task scheduling. ">TaskP_restoreScheduler()</a> to prevent the context switch.</p>
<dl class="section note"><dt>Note</dt><dd>This API cannot be called from interrupt contexts.</dd></dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TaskP</td><td>handle (NULL on failure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a88ca78b4f2572ee6a2e04bff7f8892d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ca78b4f2572ee6a2e04bff7f8892d9">&sect;&nbsp;</a></span>TaskP_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskP_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_p_8h.html#a31ff8e662723e61efd85a4db30f89628">TaskP_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a TaskP. </p>
<p>Deletes a TaskP.</p>
<dl class="section note"><dt>Note</dt><dd>This API cannot be called from interrupt contexts.</dd></dl>
<p>For FreeRTOS, INCLUDE_vTaskDelete has to be set to 1 in FreeRTOSConfig.h. See 'Configuration with FreeRTOS' in the Core SDK User's Guide for how to do this. </p>

</div>
</div>
<a id="a0bf938483764f419259c910b098b6fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf938483764f419259c910b098b6fa4">&sect;&nbsp;</a></span>TaskP_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_task_p_8h.html#a31ff8e662723e61efd85a4db30f89628">TaskP_Handle</a> TaskP_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_task_p___struct.html">TaskP_Struct</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_task_p_8h.html#ac0a57708d5950934830c66a8724fb6a5">TaskP_Function</a>&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_task_p___params.html">TaskP_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a TaskP from statically allocated memory. </p>
<p>TaskP_construct creates a new task object. TaskP_construct returns the handle of the new task object or NULL if the task could not be created.</p>
<p>To use TaskP_construct you must set both point <code>params.stack</code> to a valid preallocated memory location of at least <code>params.stackSize</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This API cannot be called from interrupt contexts.</dd></dl>
<p>For FreeRTOS, configSUPPORT_STATIC_ALLOCATION has to be set to 1 in FreeRTOSConfig.h. See 'Configuration with FreeRTOS' in the Core SDK User's Guide for how to do this.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">TaskP</td><td>handle (NULL on failure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2eacddcb7a8f8fbd37a08ea3b23b1c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eacddcb7a8f8fbd37a08ea3b23b1c28">&sect;&nbsp;</a></span>TaskP_destruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskP_destruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_task_p___struct.html">TaskP_Struct</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destruct a TaskP. </p>
<p>TaskP_destruct destructs a task object.</p>
<dl class="section note"><dt>Note</dt><dd>This API cannot be called from interrupt contexts. </dd></dl>

</div>
</div>
<a id="ab5ee6a6175e9dc75d3f47d635a9f2731"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ee6a6175e9dc75d3f47d635a9f2731">&sect;&nbsp;</a></span>TaskP_getState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_task_p_8h.html#a8f0482bc6ecdaabe28dff9e5d28198cd">TaskP_State</a> TaskP_getState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_task_p_8h.html#a31ff8e662723e61efd85a4db30f89628">TaskP_Handle</a>&#160;</td>
          <td class="paramname"><em>task</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current state of a task handle. </p>
<p>Returns the state of the referenced task at the time this function was called. The return value is not guaranteed to match the state of the task when the calling function tests the return value. For example, the referenced task might have unblocked as a result of an interrupt, but the value may still read TaskP_State_BLOCKED.</p>
<p>The conversion of task states between DPL, FreeRTOS and TI-RTOS is: DPL: FreeRTOS: TI-RTOS: TaskP_State_RUNNING - eRunning - Task_Mode_RUNNING TaskP_State_READY - eReady - Task_Mode_READY TaskP_State_BLOCKED - eBlocked - Task_Mode_BLOCKED TaskP_State_DELETED - eDeleted - Task_Mode_TERMINATED TaskP_State_INACTIVE - eSuspended - Task_Mode_INACTIVE TaskP_State_INVALID - eInvalid - N.A</p>
<p>For FreeRTOS, INCLUDE_eTaskGetState has to be set to 1 in FreeRTOSConfig.h. See 'Configuration with FreeRTOS' in the Core SDK User's Guide for how to do this.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Current</td><td>state of the task pointed to by the task parameter </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a07ad86c8971ad9ae9fd0f080b63bbb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ad86c8971ad9ae9fd0f080b63bbb61">&sect;&nbsp;</a></span>TaskP_getCurrentTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_task_p_8h.html#a31ff8e662723e61efd85a4db30f89628">TaskP_Handle</a> TaskP_getCurrentTask </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the currently executing task handle. </p>
<dl class="section note"><dt>Note</dt><dd>Must be called from task context.</dd></dl>
<p>For FreeRTOS, INCLUDE_xTaskGetCurrentTaskHandle has to be set to 1 in FreeRTOSConfig.h. See 'Configuration with FreeRTOS' in the Core SDK User's Guide for how to do this.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">The</td><td>handle for the calling task </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a23392193f7f8b3be8458519949ce4763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23392193f7f8b3be8458519949ce4763">&sect;&nbsp;</a></span>TaskP_disableScheduler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t TaskP_disableScheduler </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to disable task scheduling. </p>
<p>This function can be called multiple times, but must unwound in the reverse order. For example </p><div class="fragment"><div class="line">uintptr_t key1, key2;</div><div class="line">key1 = <a class="code" href="_task_p_8h.html#a23392193f7f8b3be8458519949ce4763">TaskP_disableScheduler</a>();</div><div class="line">key2 = <a class="code" href="_task_p_8h.html#a23392193f7f8b3be8458519949ce4763">TaskP_disableScheduler</a>();</div><div class="line"><a class="code" href="_task_p_8h.html#ae8c78742eec61d46ec4133cdee6f5ab4">TaskP_restoreScheduler</a>(key2);</div><div class="line"><a class="code" href="_task_p_8h.html#ae8c78742eec61d46ec4133cdee6f5ab4">TaskP_restoreScheduler</a>(key1);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>This API cannot be called from interrupt contexts.</dd></dl>
<p>For FreeRTOS the key value returned is always 0.</p>
<dl class="section return"><dt>Returns</dt><dd>A key to pass to TaskP_restoreScheduler to re-enable the scheduler. </dd></dl>

</div>
</div>
<a id="ae8c78742eec61d46ec4133cdee6f5ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8c78742eec61d46ec4133cdee6f5ab4">&sect;&nbsp;</a></span>TaskP_restoreScheduler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskP_restoreScheduler </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to re-enable task scheduling. </p>
<dl class="section note"><dt>Note</dt><dd>This API cannot be called from interrupt contexts.</dd></dl>
<p>For FreeRTOS the key value is ignored.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>returned from TaskP_disableScheduler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a34f74bb9a6902f4c003d2f9f9a9c427a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f74bb9a6902f4c003d2f9f9a9c427a">&sect;&nbsp;</a></span>TaskP_yield()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskP_yield </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a scheduler point, yielding to equal priority tasks. </p>
<p>Task_yield yields the processor to another task of equal priority. A task switch occurs when you call Task_yield if there is an equal priority task ready to run. </p>

</div>
</div>
<a id="ada126fc28d0aea5c60f1984dadfde56e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada126fc28d0aea5c60f1984dadfde56e">&sect;&nbsp;</a></span>TaskP_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TaskP_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_task_p___params.html">TaskP_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize params structure to default values. </p>
<p>Initialize the parameter struct with default values.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>pointer to the task parameter struct </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2024</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
