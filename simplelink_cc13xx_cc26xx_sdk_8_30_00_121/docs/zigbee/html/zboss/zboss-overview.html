<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Z-Stack Overview &mdash; 
SimpleLink™ CC13XX/CC26XX SDK
Z-Stack User&#39;s Guide
 8.30.00 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/theme_overrides.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-bootstrap.5fd3999ee7762ccc51105388f4a9d115.css" type="text/css" />
      <link rel="stylesheet" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" type="text/css" />
    <link rel="shortcut icon" href="../_static/favicon.ico"/>
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <script language="JavaScript">
        var tiPageName;
        tiPageName = "sug zboss zboss-overview";

        if (location.protocol == "file:"){
            var ci_analytics_poc_load = true;
        }
    </script>

    <script src="http://www.ti.com/assets/js/headerfooter/analytics.js" type="text/javascript" charset="utf-8"></script>


</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../zigbee-guide/index-cc13xx_cc26xx.html" class="icon icon-home"> 
SimpleLink™ CC13XX/CC26XX SDK
Z-Stack User's Guide

          </a>
              <div class="version">
                8.30.00
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../quickstart-guide/quickstart-intro-cc13xx_cc26xx.html">Introduction to the SimpleLink CC13xx/CC26xx SDK</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee/introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cc13xx_cc26xx/index-platform.html">SimpleLink Wireless MCU CC13xx and CC26xx Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/tirtos-index.html">TI-RTOS7 (RTOS Kernel) Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee/overview.html">SimpleLink CC13xx/CC26xx SDK Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee/developing_zigbee_applications.html">Developing Zigbee Applications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cc13xx_cc26xx/custom-hardware-cc13xx_cc26xx.html">Custom Hardware</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/zigbee-ota-index.html">Zigbee Over-The-Air Firmware Upgrade</a></li>
<li class="toctree-l1"><a class="reference internal" href="../coexistence/coexistence-ieee.html">Wi-Fi Coexistence</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/debugging-index.html">Debugging</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee/packet_sniffer.html">Packet Sniffer</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/sysconfig-index.html">System Configuration (SysConfig)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../energy-trace/energy-trace.html">EnergyTrace User Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/migration_guide.html">Migration Guide</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/references-cc13xx_cc26xx.html">References</a></li>
<li class="toctree-l1"><a class="reference internal" href="../zigbee-guide/glossary.html">Terms and Acronyms</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../zigbee-guide/index-cc13xx_cc26xx.html">
SimpleLink™ CC13XX/CC26XX SDK
Z-Stack User's Guide
</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../zigbee-guide/index-cc13xx_cc26xx.html" class="icon icon-home"></a> &raquo;</li>
      <li>Z-Stack Overview</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <div class="section" id="stack-overview">
<span id="z-stack-overview"></span><h1>Z-Stack Overview<a class="headerlink" href="#stack-overview" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<div class="section" id="purpose">
<h3>Purpose<a class="headerlink" href="#purpose" title="Permalink to this headline">¶</a></h3>
<p>This document describes basic concepts of Zigbee mesh networks. This is a Zigbee
PRO 2023 (R23) certified stack for the Zigbee and Zigbee PRO stack profiles.
For a more complete Z-Stack™ Release description along with stack
settings pertaining to Texas Instruments devices, please refer to the <a href="#id9"><span class="problematic" id="id10">|ZBOSS_UG|</span></a>.</p>
</div>
<div class="section" id="definitions-abbreviations-and-acronyms">
<h3>Definitions, Abbreviations and Acronyms<a class="headerlink" href="#definitions-abbreviations-and-acronyms" title="Permalink to this headline">¶</a></h3>
<table class="docutils align-default">
<colgroup>
<col style="width: 23%" />
<col style="width: 77%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Term</strong></p></th>
<th class="head"><p><strong>Definition</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>AF</p></td>
<td><p>Application Framework</p></td>
</tr>
<tr class="row-odd"><td><p>AES</p></td>
<td><p>Advanced Encryption Standard</p></td>
</tr>
<tr class="row-even"><td><p>AIB</p></td>
<td><p>APS Information Base</p></td>
</tr>
<tr class="row-odd"><td><p>API</p></td>
<td><p>Application Programming Interface</p></td>
</tr>
<tr class="row-even"><td><p>APS</p></td>
<td><p>Application Support Sub-Layer</p></td>
</tr>
<tr class="row-odd"><td><p>APSDE</p></td>
<td><p>APS Date Entity</p></td>
</tr>
<tr class="row-even"><td><p>APSME</p></td>
<td><p>APS Management Entity</p></td>
</tr>
<tr class="row-odd"><td><p>BDB</p></td>
<td><p>Base Device Behavior</p></td>
</tr>
<tr class="row-even"><td><p>CCM*</p></td>
<td><p>Enhanced counter with CBC-MAC mode of
operation</p></td>
</tr>
<tr class="row-odd"><td><p>EPID</p></td>
<td><p>Extended PAN ID</p></td>
</tr>
<tr class="row-even"><td><p>GP</p></td>
<td><p>Green Power</p></td>
</tr>
<tr class="row-odd"><td><p>GPD</p></td>
<td><p>Green Power Device</p></td>
</tr>
<tr class="row-even"><td><p>MSG</p></td>
<td><p>Message</p></td>
</tr>
<tr class="row-odd"><td><p>MT</p></td>
<td><p>Zigbee’s Monitor and Test Layer</p></td>
</tr>
<tr class="row-even"><td><p>NIB</p></td>
<td><p>Network Information Base</p></td>
</tr>
<tr class="row-odd"><td><p>NWK</p></td>
<td><p>Network</p></td>
</tr>
<tr class="row-even"><td><p>OTA</p></td>
<td><p>Over-the-Air</p></td>
</tr>
<tr class="row-odd"><td><p>PAN</p></td>
<td><p>Personal Area Network</p></td>
</tr>
<tr class="row-even"><td><p>RSSI</p></td>
<td><p>Received Signal Strength Indication</p></td>
</tr>
<tr class="row-odd"><td><p>TC</p></td>
<td><p>Trust Center</p></td>
</tr>
<tr class="row-even"><td><p>TCLK</p></td>
<td><p>Trust Center Link Key</p></td>
</tr>
<tr class="row-odd"><td><p>ZCL</p></td>
<td><p>Zigbee Cluster Library</p></td>
</tr>
<tr class="row-even"><td><p>ZDO</p></td>
<td><p>Zigbee Device Object</p></td>
</tr>
<tr class="row-odd"><td><p>ZC</p></td>
<td><p>Zigbee Coordinator</p></td>
</tr>
<tr class="row-even"><td><p>ZR</p></td>
<td><p>Zigbee Router</p></td>
</tr>
<tr class="row-odd"><td><p>ZED</p></td>
<td><p>Zigbee End Device</p></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="reference-documents">
<h3>Reference Documents<a class="headerlink" href="#reference-documents" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Zigbee document 05-3474-22 Zigbee PRO 2023 (R23) Specification</p></li>
<li><p>Zigbee document 07-5123-08 Zigbee Cluster Library 8 Specification</p></li>
<li><p>Zigbee document 13-0402-13 Zigbee Base Device Behavior</p></li>
<li><p>Zigbee document 14-0563-16 Zigbee Green Power specification</p></li>
</ol>
<p>All documentation can be located on the <a class="reference external" href="https://zigbeealliance.org/">Connectivity Standards Alliance</a> website.</p>
</div>
</div>
<div class="section" id="zigbee">
<h2>Zigbee<a class="headerlink" href="#zigbee" title="Permalink to this headline">¶</a></h2>
<p>A Zigbee network is a multi-hop network of mains-powered or battery-powered
devices. This means that successful communication between two devices may
require intermediate devices to relay messages. Due to the cooperative nature of
the network, each device is required to perform specific networking functions
and configure certain parameters to specific values. The role of a device is
determined by the set of networking functions it performs and is called the
<strong>logical device type</strong>. The set of parameters that need to be configured to
specific values, along with those values, is called the <strong>stack profile</strong>.</p>
<div class="section" id="logical-device-types">
<span id="z-stack-overview-logical-device-types"></span><h3>Logical Device Types<a class="headerlink" href="#logical-device-types" title="Permalink to this headline">¶</a></h3>
<p>The three logical device types in a Zigbee network are
<em>Coordinator</em>, <em>Router</em>, and <em>End Device</em>. A Zigbee network consists
of a device with network formation capabilities (such as Coordinator or Router)
and multiple Router and End Device nodes. Note that the device type does
not in any way restrict the type of application that may run on the
particular device.</p>
<div class="figure align-center" id="id5">
<span id="fig-typical-zigbee-nwk"></span><img alt="../_images/figure1.png" src="../_images/figure1.png" />
<p class="caption"><span class="caption-text">Example of typical Zigbee network</span><a class="headerlink" href="#id5" title="Permalink to this image">¶</a></p>
</div>
<p><a class="reference internal" href="../zigbee/z-stack-overview.html#fig-typical-zigbee-nwk"><span class="std std-ref">Example of typical Zigbee network</span></a> shows a typical Zigbee network with the Zigbee
<em>Coordinator</em> (black), the <em>Routers</em> (red), and the <em>End Devices</em> (white).</p>
<p>An application can be defined as any of these three logical devices depending
on the configuration flags enabled in the project.</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 34%" />
<col style="width: 66%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p><strong>Logical Device</strong></p></th>
<th class="head"><p><strong>Compilation flags needed</strong></p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p><em>Coordinator</em></p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">ZB_COORDINATOR_ROLE</span></code></p></td>
</tr>
<tr class="row-odd"><td><p><em>Router</em></p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">ZB_ROUTER_ROLE</span></code></p></td>
</tr>
<tr class="row-even"><td><p><em>End Device</em></p></td>
<td><p><code class="code docutils literal notranslate"><span class="pre">ZB_ED_ROLE</span></code></p></td>
</tr>
</tbody>
</table>
<div class="section" id="coordinator">
<span id="z-stack-overview-logical-device-coordinator"></span><h4>Coordinator<a class="headerlink" href="#coordinator" title="Permalink to this headline">¶</a></h4>
<p>A coordinator is a device with network formation capabilities, but
without network joining capabilities. This means the device can only create its
own network, but not join existing networks. To create a network, the
coordinator node scans the RF environment for existing networks, chooses
a channel and a network identifier (also called PAN ID) and then starts
the network. In Zigbee 3.0 this device creates a Centralized security network
and is mandated to behave as the Trust Center of this network, which
means that this device is responsible for managing security of the
network and is the only device capable of distributing keys and
allowing devices to join the network it has created.</p>
<p>The coordinator node can also be used, optionally, to assist in setting
up application-level bindings in the network.</p>
<p>The role of the coordinator is mainly related to starting the network
and managing the keys. Besides that, it behaves like a router device.
Note that the Coordinator must handle the network procedures
related to devices joining or leaving the network,
so it cannot be absent of its own network.
Further details on security schema are available in <a class="reference internal" href="../zigbee/z-stack-overview.html#z-stack-overview-security"><span class="std std-ref">Security</span></a>.</p>
</div>
<div class="section" id="router">
<span id="z-stack-overview-logical-device-router"></span><h4>Router<a class="headerlink" href="#router" title="Permalink to this headline">¶</a></h4>
<p>A router performs functions for allowing other devices to join the
network, for multi-hop routing,
and for assisting its child end devices with communication.
In Zigbee 3.0 this device has been granted with formation
capabilities that allow it to create a Distributed security network.
This formation capability allows the router device to create a network
that does not have a security manager. This means that once the network
has been created, the router which created it does not have any special
role in this network. More details are available in <a class="reference internal" href="../zigbee/z-stack-overview.html#z-stack-overview-security"><span class="std std-ref">Security</span></a>.</p>
<p>In general, Routers are expected to be active all the time and thus have
to be mains-powered.</p>
</div>
<div class="section" id="end-device">
<span id="z-stack-overview-logical-device-end-device"></span><h4>End Device<a class="headerlink" href="#end-device" title="Permalink to this headline">¶</a></h4>
<p>An end device has no specific responsibility for maintaining the network
infrastructure, so it can sleep and wake up as it chooses. This device can
be a battery-powered node. Generally, the memory requirements (especially
RAM requirements) are lower for an end device.</p>
<blockquote>
<div><div class="admonition note">
<p class="admonition-title">Note</p>
<p>In Z-Stack all sample application projects are provided with the needed
pre-include files to build each device type according to the project.</p>
</div>
</div></blockquote>
</div>
</div>
<div class="section" id="stack-layers">
<span id="z-stack-layers"></span><h3>Stack Layers<a class="headerlink" href="#stack-layers" title="Permalink to this headline">¶</a></h3>
<p>The following is a brief description of the various Z-Stack layers and their
purpose towards Zigbee functionality.  Note that Zigbee is built on top of
the IEEE 802.15.4 2006 radio specification.</p>
<ul class="simple">
<li><p>IEEE 802.15.4 PHY: The radio’s physical and electrical characteristics</p></li>
<li><p>IEEE 802.15.4 MAC: Responsible for sending and receiving RF Frames</p></li>
<li><p>Zigbee-PRO NWK: Handles packets within the confines of a Zigbee network</p></li>
<li><p>Zigbee-PRO APS: Determines now packets are interpreted by the Zigbee application</p></li>
<li><p>Zigbee Devices: Commonly referred to as ZDO, this defines how the local device
operates within a Zigbee network</p></li>
<li><p>Base Device Behavior: Standard for commissioning a device in Zigbee network</p></li>
<li><p>Manufacturers Application: Including the Zigbee Cluster Library (ZCL), this
contains the attributes and clusters which define the Zigbee device’s purpose,
behavior, and usage within the network.</p></li>
</ul>
<div class="figure align-center" id="id6">
<span id="fig-zigbee-software-architecture"></span><img alt="../_images/zigbee-software-architecture.png" src="../_images/zigbee-software-architecture.png" />
<p class="caption"><span class="caption-text">Zigbee Software Architecture</span><a class="headerlink" href="#id6" title="Permalink to this image">¶</a></p>
</div>
<p>The Zigbee PRO 2023 Compliant Platform layers are pre-built for CC13xx and CC26xx
Z-Stack devices and require no modification.  Zigbee 3.0 Base Device &amp; Clusters
layers can be further configured and determined by the developer.</p>
</div>
<div class="section" id="stack-profile">
<span id="z-stack-overview-stack-profile"></span><h3>Stack Profile<a class="headerlink" href="#stack-profile" title="Permalink to this headline">¶</a></h3>
<p>The set of stack parameters that need to be configured to specific
values, along with the above device type values, is called a <strong>stack
profile</strong>. The parameters that comprise the stack profile are defined
by the Connectivity Standards Alliance.</p>
<p>All devices in a network must conform to the same stack profile (i.e.,
all devices must have the stack profile parameters configured to the
same values).</p>
<p>If application developers choose to change the settings for any of these
parameters, they can do so with the caveat that those devices will no
longer be able to interoperate with devices from other vendors that
choose to follow the Zigbee specified stack profile. Thus, developers of
“closed networks” may choose to change the settings of the stack profile
variables. These stack profiles are called “network-specific” stack
profiles.</p>
<p>The stack profile identifier that a device conforms to is present in the
beacon transmitted by that device. This enables a device to determine
the stack profile of a network before joining to it. The
“network-specific” stack profile has an ID of 0, the legacy Zigbee
stack profile has ID of 1, and the Zigbee PRO stack profile (which is used
for Zigbee 3.0) has ID of 2. The stack profile is configured by the
<code class="code docutils literal notranslate"><span class="pre">ZB_STACK_PROFILE</span></code> parameter in the <code class="code docutils literal notranslate"><span class="pre">zb_config.h</span></code> file.
The stack profile ID of 3 is reserved for Green Power devices, and it
appears in the respective frames.</p>
</div>
</div>
<div class="section" id="addressing">
<span id="z-stack-overview-addressing"></span><h2>Addressing<a class="headerlink" href="#addressing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="address-types">
<span id="z-stack-overview-address-types"></span><h3>Address Types<a class="headerlink" href="#address-types" title="Permalink to this headline">¶</a></h3>
<p>Zigbee devices have two types of addresses. A 64-bit <em>IEEE address</em>
(also called <em>MAC address</em> or <em>Extended address</em>) and a 16-bit <em>network
address</em> (also called <em>logical address</em> or <em>short address</em>).</p>
<p>The 64-bit address is a globally unique address and is assigned to the
device for its lifetime. It is usually set by the manufacturer or during
installation. These addresses are maintained and allocated by the IEEE.
More information on how to acquire a block of these addresses is
available at <a class="reference external" href="https://standards.ieee.org/products-services/regauth/index.html">IEEE Registration Authority</a>.</p>
<p>The 16-bit address is assigned to a device when it joins a network.
Within that network, it is unique and used for identifying devices and sending data.</p>
</div>
<div class="section" id="network-address-assignment">
<span id="z-stack-overview-network-address-assignment"></span><h3>Network Address Assignment<a class="headerlink" href="#network-address-assignment" title="Permalink to this headline">¶</a></h3>
<div class="section" id="stochastic-addressing">
<h4>Stochastic Addressing<a class="headerlink" href="#stochastic-addressing" title="Permalink to this headline">¶</a></h4>
<p>Zigbee PRO uses a stochastic (random) addressing scheme for assigning
the network addresses. This addressing scheme randomly assigns short
addresses to new devices, and then uses the rest of the devices in the
network to ensure there are no duplicate addresses. When a device
joins, it receives its randomly generated address from its parent. The
new network node then generates a “Device Announce” frame (which contains its
new short address and its extended address) to the rest of the network.
If there is another device with the same short address, a router node
in the network will send out a broadcast “Network Status – Address
Conflict” to the entire network and all devices with the conflicting
short address will change its short address. When the conflicted devices
change their address, they issue their own “Device Announce” to check
their new address for conflicts within the network.</p>
<p>End devices do not participate in the “Address Conflict”. Their parents
do that for them. If an “Address Conflict” occurs for an end device, its
parent will issue the end device a “Rejoin Response” message to change
the end device’s short address and the end device issues a “Device
Announce” to check their new address for conflicts within the network.</p>
<p>When a “Device Announce” is received, the association and binding tables
are updated with the new short address, but routing table information is not
updated (new routes must be established). If a parent determines that
the “Device Announce” pertains to one of its end device children, but it
didn’t come directly from the child, the parent will assume that the
child moved to another parent.</p>
</div>
</div>
<div class="section" id="addressing-in-stack">
<span id="z-stack-overview-addressing-in-z-stack"></span><h3>Addressing in Z-Stack<a class="headerlink" href="#addressing-in-stack" title="Permalink to this headline">¶</a></h3>
<p>In order to send data to a device on the Zigbee network, the application must
determine a destination address.  In addition to the address itself, the address
mode parameter also needs to be specified. The destination address mode can take
one of the following values (defined in <code class="code docutils literal notranslate"><span class="pre">zboss_api_aps.h</span></code>):</p>
<div class="highlight-c notranslate"><div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm">* @name APS addressing mode constants</span>
<span class="cm">* @anchor aps_addr_mode</span>
<span class="cm">*/</span><span class="w"></span>
<span class="cm">/** @{ */</span><span class="w"></span>
<span class="cp">#define ZB_APS_ADDR_MODE_DST_ADDR_ENDP_NOT_PRESENT  0x00U </span><span class="cm">/*!&lt; DstAddress and DstEndpoint not present  */</span><span class="cp"></span>
<span class="cp">#define ZB_APS_ADDR_MODE_16_GROUP_ENDP_NOT_PRESENT  0x01U </span><span class="cm">/*!&lt; 16-bit group address for DstAddress; DstEndpoint not present */</span><span class="cp"></span>
<span class="cp">#define ZB_APS_ADDR_MODE_16_ENDP_PRESENT            0x02U </span><span class="cm">/*!&lt; 16-bit address for DstAddress and DstEndpoint present */</span><span class="cp"></span>
<span class="cp">#define ZB_APS_ADDR_MODE_64_ENDP_PRESENT            0x03U </span><span class="cm">/*!&lt; 64-bit extended address for DstAddress and DstEndpoint present  */</span><span class="cp"></span>
<span class="cp">#define ZB_APS_ADDR_MODE_BIND_TBL_ID                0x04U </span><span class="cm">/*!&lt; &quot;destination endpoint&quot; is interpreted as an index in the binding table,</span>
<span class="cm">                                                            all other destination address information is ignored */</span><span class="cp"></span>
</pre></div>
</div>
<p>The address mode parameter is necessary because, in Zigbee, packets can
be unicast, multicast, or broadcast. A unicast packet is sent to a single
device, a multicast packet is destined to a group of devices and a
broadcast packet is generally sent to all devices in the network. An indirect
packet is used when the application does not explicitly know the destination of
the packet. This is explained in more detail below.</p>
<div class="section" id="unicast">
<h4>Unicast<a class="headerlink" href="#unicast" title="Permalink to this headline">¶</a></h4>
<p>This is the normal addressing mode and is used to send a packet to a
single device whose network address is known. The address mde is set to
<code class="code docutils literal notranslate"><span class="pre">ZB_APS_ADDR_MODE_16_ENDP_PRESENT</span></code> and the destination network address is
carried in the packet.</p>
</div>
<div class="section" id="indirect">
<h4>Indirect<a class="headerlink" href="#indirect" title="Permalink to this headline">¶</a></h4>
<p>This is when the application is not aware of the final destination of
the packet. The mode is set to <code class="code docutils literal notranslate"><span class="pre">ZB_APS_ADDR_MODE_DST_ADDR_ENDP_NOT_PRESENT</span></code>
and the destination address is not specified. Instead, the destination is looked
up from a <em>binding table</em> that resides in the stack of the sending device. This
feature is called Source binding (see <a class="reference internal" href="../zigbee/z-stack-overview.html#z-stack-overview-binding"><span class="std std-ref">Binding</span></a>).</p>
<p>When the packet is sent down to the stack, the destination address and
end point is looked up from the binding table and used. The packet is
then treated as a regular unicast packet. If more than one destination
device is found in the binding table, a copy of the packet is sent to
each of them. If no binding entry is found, the packet will not be sent.</p>
</div>
<div class="section" id="broadcast">
<h4>Broadcast<a class="headerlink" href="#broadcast" title="Permalink to this headline">¶</a></h4>
<p>This address mode is used when the application wants to send a packet to
all devices in the network. The address mode is set to
<code class="code docutils literal notranslate"><span class="pre">ZB_APS_ADDR_MODE_16_ENDP_PRESENT</span></code> and the destination address can be set
to one of the following broadcastaddresses:</p>
<p>0xFFFF – the message will be sent to all devices in the network (includes
sleeping devices). For sleeping devices, the message is held at its parent until
the sleeping device polls for it or the message is timed out
(<code class="code docutils literal notranslate"><span class="pre">NWK_INDIRECT_MSG_TIMEOUT</span></code> in
<code class="code docutils literal notranslate"><span class="pre">ti_zstack_config.h</span></code>, as generated from the project’s .syscfg file
<em>RF STACKS</em> → <em>Z-Stack</em> → <em>Advanced</em> → <em>Routing</em>).</p>
<p>0xFFFD – the message will be sent to all devices that have the receiver on when
idle (RXONWHENIDLE), that is, all non-sleepy devices.</p>
<p>0xFFFC – the message is sent to all routers (including the coordinator).</p>
</div>
<div class="section" id="group-addressing">
<h4>Group Addressing<a class="headerlink" href="#group-addressing" title="Permalink to this headline">¶</a></h4>
<p>This address mode is used when the application wants to send a packet to
a group of devices. The address mode is set to <code class="code docutils literal notranslate"><span class="pre">ZB_APS_ADDR_MODE_16_GROUP_ENDP_NOT_PRESENT</span></code>
and the address parameter must be set set with the group identifier.</p>
<p>Note that groups can also be used in conjunction with indirect
addressing. The destination address found in the binding table can be
either a unicast or a group address. Also note that broadcast addressing
is simply a special case of group addressing where the groups are set up
ahead of time and defined by Connectivity Standards Alliance.</p>
</div>
</div>
<div class="section" id="important-device-addresses">
<h3>Important Device Addresses<a class="headerlink" href="#important-device-addresses" title="Permalink to this headline">¶</a></h3>
<p>An application may want to know the address of a device (local).
Use the following functions to get the addresses.</p>
<ul class="simple">
<li><p><code class="code docutils literal notranslate"><span class="pre">MAC_PIB().mac_short_address</span></code> – Retrieve the short address.</p></li>
<li><p><code class="code docutils literal notranslate"><span class="pre">MAC_PIB().mac_extended_address</span></code> – Retrieve the IEEE address.</p></li>
</ul>
</div>
</div>
<div class="section" id="binding">
<span id="z-stack-overview-binding"></span><h2>Binding<a class="headerlink" href="#binding" title="Permalink to this headline">¶</a></h2>
<p>Binding is a mechanism to control the flow of messages from one
application to another application (or multiple applications). The
binding mechanism is implemented in all devices and is called source
binding.</p>
<p>Binding allows an application to send a packet without knowing the
destination address, the APS layer determines the destination address from its
binding table, and then forwards the message to the destination application (or
multiple applications) or group.</p>
<div class="section" id="building-a-binding-table">
<span id="z-stack-overview-building-binding-table"></span><h3>Building a Binding Table<a class="headerlink" href="#building-a-binding-table" title="Permalink to this headline">¶</a></h3>
<p>There are 3 ways to build a binding table:</p>
<ul class="simple">
<li><p>Zigbee Device Object Bind Request – a commissioning tool can tell the
device to make a binding record.</p></li>
<li><p>Zigbee Device Object End Device Bind Request – 2 devices can tell the
coordinator that they would like to setup a binding table record. The
coordinator will make the match up and create the binding table
entries in the 2 devices.</p></li>
<li><p>Finding and Binding commissioning process for initiator devices.</p></li>
</ul>
<div class="section" id="zigbee-device-object-bind-request">
<h4>Zigbee Device Object Bind Request<a class="headerlink" href="#zigbee-device-object-bind-request" title="Permalink to this headline">¶</a></h4>
<p>Any device or application can send a ZDO message to another device (over
the air) to build a binding record for that other device in the network.
This is called Assisted Binding and it will create a binding entry for
the sending device.</p>
<div class="section" id="the-commissioning-application">
<h5>The Commissioning Application<a class="headerlink" href="#the-commissioning-application" title="Permalink to this headline">¶</a></h5>
<p>An application can create a bind between two remote devices by calling
<code class="code docutils literal notranslate"><span class="pre">zb_zdo_bind_req()`for</span> <span class="pre">which</span> <span class="pre">are</span> <span class="pre">needed</span> <span class="pre">the</span> <span class="pre">addresses,</span> <span class="pre">endpoints,</span> <span class="pre">and</span> <span class="pre">the</span>
<span class="pre">cluster</span> <span class="pre">ID</span> <span class="pre">wanted</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">binding</span> <span class="pre">record.</span> <span class="pre">The</span> <span class="pre">first</span> <span class="pre">parameter</span> <span class="pre">(target</span> <span class="pre">dstAddr)</span>
<span class="pre">is</span> <span class="pre">the</span> <span class="pre">short</span> <span class="pre">address</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">binding’s</span> <span class="pre">source</span> <span class="pre">address</span> <span class="pre">(where</span> <span class="pre">the</span> <span class="pre">binding</span> <span class="pre">record</span>
<span class="pre">will</span> <span class="pre">be</span> <span class="pre">stored)</span> <span class="pre">.</span> <span class="pre">The</span> <span class="pre">remaining</span> <span class="pre">parameters</span> <span class="pre">are</span> <span class="pre">of</span> <span class="pre">the</span> <span class="pre">remote</span> <span class="pre">application</span> <span class="pre">device</span>
<span class="pre">that</span> <span class="pre">the</span> <span class="pre">bind</span> <span class="pre">will</span> <span class="pre">use</span> <span class="pre">to</span> <span class="pre">send</span> <span class="pre">frames.</span> <span class="pre">Calling</span> <span class="pre">:code:`zb_zdo_unbind_req()</span></code>
can be used, with the same parameters, to remove the binding record.</p>
<p>The target device will send back a Zigbee Device Object Bind or Unbind
Response message. The ZDO code on the coordinator will parse this and
notify the application with either the ZDP transaction sequence number or
0xFF if operation cannot be performed now (nor enough memory, resources, etc.)</p>
</div>
</div>
<div class="section" id="finding-and-binding">
<h4>Finding and Binding<a class="headerlink" href="#finding-and-binding" title="Permalink to this headline">¶</a></h4>
<p>Base Device Behavior has defined a commissioning method called Finding
and Binding, which is a process that relies on the usage of the Identify
cluster and ZDO messages to allow the commissioned device to find
devices with matching application clusters. This mechanism is usually
triggered by the user to specify which devices need to “Find and Bind”
each other so that these pairs of devices can communicate more effectively.
Refer to section <a class="reference internal" href="../zigbee/z-stack-overview.html#z-stack-overview-finding-binding"><span class="std std-ref">Finding and Binding</span></a> for further details on
this commissioning method.</p>
</div>
</div>
</div>
<div class="section" id="routing">
<span id="z-stack-overview-routing-overview"></span><h2>Routing<a class="headerlink" href="#routing" title="Permalink to this headline">¶</a></h2>
<div class="section" id="overview">
<h3>Overview<a class="headerlink" href="#overview" title="Permalink to this headline">¶</a></h3>
<p>A mesh network is described as a network in which the routing of
messages is performed as a decentralized, cooperative process involving
many peer devices routing on each others’ behalf.</p>
<p>The routing is completely hidden from the application layer.
The application simply sends data destined to any device down to the stack
which is then responsible for finding a route. In other words, the application
is unaware of the fact that it is operating in a multi-hop network.</p>
<p>Routing also enables the “self healing” nature of Zigbee networks. If a
particular wireless link is down, the routing functions will eventually
find a new route that avoids that particular broken link. This greatly
enhances the reliability of the wireless network and is one of the key
features of Zigbee.</p>
<p>Many-to-One routing is a special routing scheme that handles the
scenario where centralized traffic is involved. It is part of the Zigbee
PRO feature set to help minimize traffic particularly when all the
devices in the network are sending packets to a gateway or data
concentrator. Many-to-One route discovery is described in detail in
section <a class="reference internal" href="../zigbee/z-stack-overview.html#z-stack-overview-many-to-one-routing-protocol"><span class="std std-ref">Many-to-One Routing Protocol</span></a>.</p>
</div>
<div class="section" id="routing-protocol">
<span id="z-stack-overview-routing-protocol"></span><h3>Routing Protocol<a class="headerlink" href="#routing-protocol" title="Permalink to this headline">¶</a></h3>
<p>Zigbee uses a routing protocol that is based on the AODV (Ad-hoc
On-demand Distance Vector) routing protocol for ad-hoc networks.
Simplified for use in sensor networks, the Zigbee routing protocol
facilitates an environment capable of supporting mobile nodes, link
failures and packet losses.</p>
<p>Neighbor routers are routers that are within radio range of each other.
Each router keeps track of their neighbors in a “neighbor table”, and
the “neighbor table” is updated when the router receives any message
from a neighbor router (unicast, broadcast, or beacon).</p>
<p>When a router receives a unicast packet, from its application or from
another device, the NWK layer forwards it according to the following
procedure. If the destination is one of the neighbors of the router
(including its child devices) the packet will be transmitted directly to
the destination device. Otherwise, the router will check its routing
table for an entry corresponding to the routing destination of the
packet. If there is an active routing table entry for the destination
address, the packet will be relayed to the next hop address stored in
the routing entry. If a single transmission attempt fails, the NWK layer
will repeat the process of transmitting the packet and waiting for the
acknowledgement, up to a maximum of -nwk data retry times.
If an active entry cannot be found in the routing table
or using an entry failed after the maximum number of retries, a route
discovery is initiated and the packet is buffered until that process is
completed.</p>
<p>Zigbee End Devices do not perform any routing functions. An end device
wishing to send a packet to any device simply forwards it to its parent
device which will perform the routing on its behalf. Similarly, when any
device wishes to send a packet to an end device and initiate route
discovery, the parent of the end device responds on its behalf.</p>
<p>Also in Z-Stack, the routing implementation has optimized the routing
table storage. In general, a routing table entry is needed for each
destination device. But by combining all the entries for end devices of
a particular parent with the entry for that parent device, storage is
optimized without loss of any functionality.</p>
<p>Zigbee routers, including the coordinator, perform the following routing
functions:
-  Route discovery and selection
-  Route maintenance
-  Route expiry
These are explained in more detail below.</p>
<div class="section" id="route-discovery-and-selection">
<h4>Route Discovery and Selection<a class="headerlink" href="#route-discovery-and-selection" title="Permalink to this headline">¶</a></h4>
<p>Route discovery is the procedure whereby network devices cooperate to
find and establish routes through the network. A route discovery can be
initiated by any router device and is always performed in regard to a
particular destination device. The route discovery mechanism searches
all possible routes between the source and destination devices and tries
to select the best possible route.</p>
<p>Route selection is performed by choosing the route with the least
possible cost. Each node constantly keeps track of “link costs” to all
of its neighbors. The link cost is typically a function of the strength
of the received signal. By adding up the link costs for all the links
along a route, a “route cost” is derived for the whole route. The
routing algorithm tries to choose the route with the least “route cost”.</p>
<p>Routes are discovered by using request/response packets. A source device
requests a route for a destination address by broadcasting a Route
Request (RREQ) packet to its neighbors. When a node receives an RREQ
packet it in turn rebroadcasts the RREQ packet. But before doing that,
it updates the cost field in the RREQ packet by adding the link cost for
the latest link and makes an entry in its <a class="reference internal" href="../zigbee/z-stack-overview.html#z-stack-overview-route-discovery-table"><span class="std std-ref">Route Discovery Table</span></a>.</p>
<p>This way, the RREQ packet carries the sum of the link costs along all
the links that it traverses. This process repeats until the RREQ reaches
the destination device. Many copies of the RREQ will reach the
destination device traveling via different possible routes. Each of
these RREQ packets will contain the total route cost along the route
that it traveled. The destination device selects the best RREQ packet
and sends back a Route Reply (RREP) back to the source.</p>
<p>The RREP is unicast along the reverse routes of the intermediate nodes
until it reaches the original requesting node. As the RREP packet
travels back to the source, the intermediate nodes update their routing
tables to indicate the route to the destination. The Route Discovery
Table, at each intermediate node, is used to determine the next hop of
the RREP traveling back to the source of the RREQ and to make the entry
in to the Routing Table.</p>
<p>Once a route is created, data packets can be sent. When a node loses
connectivity to its next hop (it doesn’t receive a MAC ACK when sending
data packets), the node invalidates its route by sending an RERR to all
nodes that potentially received its RREP and marks the link as bad in
its Neighbor Table. Upon receiving a RREQ, RREP, or RERR, the nodes
update their routing tables.</p>
</div>
<div class="section" id="route-maintenance">
<h4>Route Maintenance<a class="headerlink" href="#route-maintenance" title="Permalink to this headline">¶</a></h4>
<p>Mesh networks provide route maintenance and self healing. Intermediate
nodes keep track of transmission failures along a link. If a link
(between neighbors) is determined as bad, the upstream node will
initiate route repair for all routes that use that link. This is done by
initiating a rediscovery of the route the next time a data packet
arrives for that route. If the route rediscovery cannot be initiated, or
it fails for some reason, a route error (RERR) packet is sent back to
source of the data packet, which is then responsible for initiating the
new route discovery. Either way the route gets re-established
automatically.</p>
</div>
<div class="section" id="route-expiry">
<h4>Route Expiry<a class="headerlink" href="#route-expiry" title="Permalink to this headline">¶</a></h4>
<p>The routing table maintains entries for established routes. If no data
packets are sent along a route for a period of time, the route will be
marked as expired. Expired routes are not deleted until space is needed.
Thus routes are not deleted until it is absolutely necessary.</p>
</div>
</div>
<div class="section" id="table-storage">
<span id="z-stack-overview-routing-table-storage"></span><h3>Table Storage<a class="headerlink" href="#table-storage" title="Permalink to this headline">¶</a></h3>
<p>The routing functions require the routers to maintain some tables.</p>
<div class="section" id="routing-table">
<h4>Routing Table<a class="headerlink" href="#routing-table" title="Permalink to this headline">¶</a></h4>
<p>Each Zigbee router, including the Zigbee coordinator, contains a routing
table in which the device stores information required to participate in
the routing of packets. Each routing table entry contains the
destination address, the next hop node, and the link status. All packets
sent to the destination address are routed through the next hop node.
Also entries in the routing table can expire in order to reclaim table
space from entries that are no longer in use.</p>
<p>Routing table capacity indicates that a device routing table has a free
routing table entry or it already has a routing table entry
corresponding to the destination address. The routing table size is
configured by <code class="code docutils literal notranslate"><span class="pre">ZB_CONFIG_NWK_ROUTING_TABLE_SIZE</span></code> in the
<code class="code docutils literal notranslate"><span class="pre">zb_mem_config_common.h</span></code> file. See the section on Route Maintenance for
route expiration details.</p>
</div>
<div class="section" id="route-discovery-table">
<span id="z-stack-overview-route-discovery-table"></span><h4>Route Discovery Table<a class="headerlink" href="#route-discovery-table" title="Permalink to this headline">¶</a></h4>
<p>Router devices involved in route discovery, maintain a route discovery
table. This table is used to store temporary information while a route
discovery is in progress. These entries only last for the duration of
the route discovery operation. Once an entry expires it can be used for
another route discovery operation. Thus this value determines the
maximum number of route discoveries that can be simultaneously performed
in the network.</p>
</div>
</div>
<div class="section" id="many-to-one-routing-protocol">
<span id="z-stack-overview-many-to-one-routing-protocol"></span><h3>Many-to-One Routing Protocol<a class="headerlink" href="#many-to-one-routing-protocol" title="Permalink to this headline">¶</a></h3>
<p>The following explains Many-to-One and source routing procedure for
users’ better understanding of Zigbee routing protocol. In reality, all
routings are taken care in the network layer and transparent to the
application. Issuing Many-to-One route discovery and route maintenance
are application decisions.</p>
<div class="section" id="many-to-one-routing-overview">
<h4>Many-to-One Routing Overview<a class="headerlink" href="#many-to-one-routing-overview" title="Permalink to this headline">¶</a></h4>
<p>Many-to-One routing is adopted in Zigbee PRO to help minimize traffic
particularly when centralized nodes are involved. It is common for low
power wireless networks to have a device acting as a gateway or data
concentrator. All nodes in the networks shall maintain at least one
valid route to the central node. To achieve this, all nodes have to
initiate route discovery for the concentrator, relying on the existing
Zigbee AODV based routing solution. The route request broadcasts will
add up and produce huge network traffic overhead. To better optimize the
routing solution, Many-to-One routing is adopted to allow a data
concentrator to establish routes from all nodes in the network with one
single route discovery and minimize the route discovery broadcast storm.</p>
<p>Source routing is part of the Many-to-One routing that provides an
efficient way for concentrator to send response or acknowledgement back
to the destination. The concentrator places the complete route
information from the concentrator to the destination into the data frame
which needs to be transmitted. It minimizes the routing table size and
route discovery traffic in the network.</p>
</div>
<div class="section" id="many-to-one-route-discovery">
<h4>Many-to-One Route Discovery<a class="headerlink" href="#many-to-one-route-discovery" title="Permalink to this headline">¶</a></h4>
<p>The following figure shows an example of the Many-to-One route discovery
procedure. To initiate Many-to-One route discovery, the concentrator
broadcast a Many-to-One route request to the entire network. Upon
receipt of the route request, every device adds a route table entry for
the concentrator and stores the one hop neighbor that relays the request
as the next hop address. No route reply will be generated.</p>
<div class="figure align-center" id="id7">
<img alt="../_images/figure2.png" src="../_images/figure2.png" />
<p class="caption"><span class="caption-text">Many-to-One route discovery illustration</span><a class="headerlink" href="#id7" title="Permalink to this image">¶</a></p>
</div>
<p>Many-to-One route request command is similar to unicast route request
command with same command ID and payload frame format. The option field
in route request is Many-to-One and the destination address is 0xFFFC.</p>
</div>
<div class="section" id="route-record-command">
<h4>Route Record Command<a class="headerlink" href="#route-record-command" title="Permalink to this headline">¶</a></h4>
<p>The above Many-to-One route discovery procedure establishes routes from
all devices to the concentrator. The reverse routing (from concentrator
to other devices) is done by route record command (source routing
scheme). The procedure is provided in the <a class="reference internal" href="../zigbee/z-stack-overview.html#fig-figure3"><span class="std std-ref">Route record command (source routing) illustration</span></a>. <em>R1</em>
sends data packet DATA to the concentrator using the previously
established Many-to-One route and expects an acknowledgement back. To
provide a route for the concentrator to send the ACK back, <em>R1</em> sends
route record command along with the data packet which records the
routing path the data packet goes through and offers the concentrator a
reverse path to send the ACK back.</p>
<div class="figure align-center" id="id8">
<span id="fig-figure3"></span><img alt="../_images/figure3.png" src="../_images/figure3.png" />
<p class="caption"><span class="caption-text">Route record command (source routing) illustration</span><a class="headerlink" href="#id8" title="Permalink to this image">¶</a></p>
</div>
<p>Upon receipt of the route record command, devices on the relay path will
append their own network addresses to the relay list in the route record
command payload. By the time the route record command reaches the
concentrator, it includes the complete routing path through which the
data packet is relayed to the concentrator. Whenever the concentrator sends
an APS ACK to <em>R1</em> in response to a data frame (not due to a route record
command itself), it shall include the source route (relay list) in the
network layer header of the packet. All devices receiving the packet
shall relay the packet to the next hop device according to the source
route.</p>
<p>A concentrator with no memory constraints can store all route
record entries it receives and use them to send packets to the source
devices in the future. Therefore, devices only need to send a route record
command once. However, for a concentrator without source route caching
capability, devices always need to send route record commands along with
data packets. The concentrator will store the source route temporarily
in the memory and then discard it after usage.</p>
<p>In brief, Many-to-One routing is an efficient enhancement to the regular
Zigbee unicast routing when most devices in the network are funneling
traffic to a single device. As part of the Many-to-One routing, source
routing is only utilized under certain circumstances. First, it is used
when the concentrator is responding to a request initiated by the source
device. Second, the concentrator should store the source route
information for all devices if it has sufficient memory. If not,
whenever devices issue requests to the concentrator, they should also
send a route record along with it.</p>
</div>
<div class="section" id="many-to-one-route-maintenance">
<h4>Many-to-One Route Maintenance<a class="headerlink" href="#many-to-one-route-maintenance" title="Permalink to this headline">¶</a></h4>
<p>If a link failure is encountered while a device is forwarding a
Many-to-One routed frame (notice that a Many-to-One routed frame itself
has no difference from a regular unicast data packet, however, the
routing table entry has a field to specify that the destination is a
concentrator), the device will generate a network status command with
code “Many-to-One route failure”. The network status command will be
relayed to the concentrator through a random neighbor and hopefully that
neighbor still has a valid route to the concentrator. When the
concentrator receives the route failure, the application will decide
whether or not to re-issue a Many-to-One route request.</p>
</div>
</div>
<div class="section" id="router-off-network-association-cleanup">
<span id="z-stack-overview-routing-off-network-association-cleanup"></span><h3>Router Off-Network Association Cleanup<a class="headerlink" href="#router-off-network-association-cleanup" title="Permalink to this headline">¶</a></h3>
<p>In case a Zigbee Router gets off network for a long period of time, its
children will try to join an alternative parent. When the router is back
online, the children will still appear in its child table, preventing
proper routing of egress traffic to them.</p>
</div>
</div>
<div class="section" id="portable-devices">
<span id="z-stack-overview-portable-devices"></span><h2>Portable Devices<a class="headerlink" href="#portable-devices" title="Permalink to this headline">¶</a></h2>
<p>An End Device detects that a parent isn’t responding either through
polling (MAC data requests) failures and/or through data message
failures.</p>
<p>When the network layer detects that its parent isn’t responding, it will trigger
the process of scanning the channel in which this device was commissioned,
in order to search another suitable parent device. It is recommended
that as soon as an end device loses its parent, it should try to
recover. If recovery fails, the device should try once again after a
short delay, and if it still fails, it should retry periodically with a
larger waiting period. This practice allows for better power usage on
the end device and does not interfere with other networks that may be on
the same channel.</p>
<p>In secure networks, it is assumed that the device already has a key and
a new key isn’t issued to the device.</p>
<p>The end device’s short address is retained when it moves from parent to
parent; routes to such end devices are re-established automatically.</p>
</div>
<div class="section" id="end-to-end-acknowledgements">
<span id="z-stack-overview-end-toend-ack"></span><h2>End-to-End Acknowledgements<a class="headerlink" href="#end-to-end-acknowledgements" title="Permalink to this headline">¶</a></h2>
<p>For non-broadcast messages, there are basically 2 types of message
retries: end-to-end acknowledgement (APS ACK) and single-hop
acknowledgement (MAC ACK). MAC ACKs are always on by default and are
usually sufficient to guarantee a high degree of reliability in the
network. To provide additional reliability, as well as to enable the sending device
to get confirmation that a packet has been delivered to its destination,
APS acknowledgements may be used.</p>
<p>APS acknowledgement is done at the APS layer and is an acknowledgement
system from the destination device to the source device. The sending
device will hold the message until the destination device sends an APS
ACK message indicating that it received the message.</p>
</div>
<div class="section" id="miscellaneous">
<span id="z-stack-overview-miscellaneous"></span><h2>Miscellaneous<a class="headerlink" href="#miscellaneous" title="Permalink to this headline">¶</a></h2>
<div class="section" id="configuring-channel">
<span id="z-stack-overview-configuring-channel"></span><h3>Configuring Channel<a class="headerlink" href="#configuring-channel" title="Permalink to this headline">¶</a></h3>
<p>Every Zigbee 3.0 device has a primary channel mask configuration
(<code class="code docutils literal notranslate"><span class="pre">DEFAULT_CHANLIST</span></code>). For devices with formation capabilities that were
instructed to create a network, these
channels masks are used when scanning for a channel with the least
number of networks to create the new network on. For devices with joining
capabilities that were instructed to join a network, these channel masks
are used when scanning for existing networks to join. The device will
try first with all the channels defined in the primary channel mask.
If the process is not successful
(the network was not created or no network to join was found),
then the secondary channel mask is used.
These two channel masks can be configured by the application as needed. A
value of 0 in one of these masks will disable the respective channel
scanning phase (primary or secondary).</p>
<p>The default primary channel mask is defined as <code class="code docutils literal notranslate"><span class="pre">DEFAULT_CHANLIST</span></code>, in
<code class="code docutils literal notranslate"><span class="pre">ti_zigbee_config.h</span></code>, which is generated from the project’s .syscfg
(<em>RF STACKS</em> → <em>Zigbee</em> → <em>Radio</em>). The
<a class="reference internal" href="../zigbee/z-stack-overview.html#z-stack-overview-commissioning"><span class="std std-ref">Commissioning</span></a> section provides more details on the
commissioning methods.</p>
</div>
<div class="section" id="configuring-the-pan-id-and-network-to-join">
<span id="z-stack-overview-configuring-pan-id-and-network-joining"></span><h3>Configuring the PAN ID and Network to Join<a class="headerlink" href="#configuring-the-pan-id-and-network-to-join" title="Permalink to this headline">¶</a></h3>
<p>The 16-bit PANID of a network is determined by the <code class="code docutils literal notranslate"><span class="pre">ZDAPP_CONFIG_PAN_ID</span></code>
parameter in <code class="code docutils literal notranslate"><span class="pre">ti_zstack_config.h</span></code>, as generated by the .syscfg file of the
project (see <a class="reference internal" href="../sysconfig/zigbee.html#sysconfig-zigbee-configuration"><span class="std std-ref">Zigbee Configuration</span></a>).</p>
<p>If set to a value between 0x0000 and 0xFFFE (inclusive),
a coordinator or a network-forming router will use this value as the PAN ID of
the network when instructed to create a network, and a joining router or end
device will only join a network that has a PAN ID which matches the value of
this parameter.</p>
<p>If set to 0xFFFF,
a newly formed network will have a random PAN ID, and
a joining device will be able to join any network regardless of its PAN ID.</p>
<p>This is an optional configuration item to control which network a Zigbee
Router or End Device will join. It can also be used to pre-set the PAN
ID of a new network that a coordinator or router will create.</p>
<p>The network discovery process is managed by the Network Steering
commissioning process, which is explained in <a class="reference internal" href="../zigbee/z-stack-overview.html#z-stack-overview-nwk-steering-not-on-nwk"><span class="std std-ref">Network Steering Procedure for a Node not on a Network</span></a>.
It allows filtering of the discovered networks.
After the scan (using either primary or secondary channel masks) is complete,
the application receives a list of network descriptors of the networks
found during the scan.</p>
</div>
<div class="section" id="maximum-payload-size">
<span id="z-stack-overview-maximum-payload-size"></span><h3>Maximum Payload Size<a class="headerlink" href="#maximum-payload-size" title="Permalink to this headline">¶</a></h3>
<p>The maximum payload size for an application is based on several factors.
The MAC layer provides a constant payload length of 125 bytes. The NWK layer requires a
fixed header size, one size with security and one without security. The
APS layer has a required, but variable, header size based on a variety
of settings, including the Zigbee Protocol Version, APS frame control
settings, etc. Ultimately, the user does not have to calculate the
maximum payload size using the aforementioned factors.</p>
</div>
<div class="section" id="leave-network">
<span id="z-stack-overview-leave-nwk"></span><h3>Leave Network<a class="headerlink" href="#leave-network" title="Permalink to this headline">¶</a></h3>
<p>The ZDO Management implements the function <code class="code docutils literal notranslate"><span class="pre">zb_zdo_mgmt_leave_req()</span></code>,
which provides access to the “NLME-LEAVE.request” primitive.
“NLME-LEAVE.request” allows a device to remove itself or a remote
device from the network.  When a device removes a child device, it also removes
the device from the local “association table”. The NWK address will only be
reused in the case where a child device is a Zigbee End Device. In the case of
a child Zigbee Router, the NWK address will not be reused.</p>
<p>If the parent of a child device leaves the network, the child will stay
on the network.</p>
<p>Since R21 of the Zigbee PRO specification, processing of “NWK Leave
Request” has been configurable for Routers. Processing
of these commands, depending on the logical device type, has also changed:
Coordinators do not process leave commands, Router devices process leave
commands from <em>any</em> device in the network (if allowed as mentioned
above), and end devices only process leave commands from their parent
device.</p>
<p>In the Base Device Behavior Specification, it is also stated that if any
device receives a valid leave request with rejoin set to <code class="code docutils literal notranslate"><span class="pre">FALSE</span></code> (meaning
that this device shall not rejoin the network), then that device is
forced to perform a Factory New reset. In this case, Z-Stack clears all
the Zigbee persistent data, while it is up to the application to clear
the relevant application data from NV.</p>
</div>
<div class="section" id="descriptors">
<span id="z-stack-overview-descriptors"></span><h3>Descriptors<a class="headerlink" href="#descriptors" title="Permalink to this headline">¶</a></h3>
<p>All devices in a Zigbee network have descriptors that describe the type
of device and its applications. This information is available to be
discovered by other devices in the network.</p>
</div>
<div class="section" id="asynchronous-links">
<span id="sec-asynchronous-links"></span><h3>Asynchronous Links<a class="headerlink" href="#asynchronous-links" title="Permalink to this headline">¶</a></h3>
<p>An asynchronous link occurs when a node can receive packets from another
node but it can’t send packets to that node. Whenever this happens, this
link is not a good link to route packets.</p>
<p>In Zigbee PRO, this problem is overcome by the use of the Network Link
Status message. Every router in a Zigbee PRO network sends a periodic
Link Status message. This message is a one hop broadcast message that
contains the sending device’s neighbor list. The idea is this – if you
receive your neighbor’s Link Status and you are either missing from the
neighbor list or your receive cost is too low (in the list), you can
assume that the link between you and this neighbor is an asynchronous
link and you should not use it for routing.</p>
<p>To change the time between Link Status messages you can change the
compile flag <code class="code docutils literal notranslate"><span class="pre">ZB_NWK_LINK_STATUS_PERIOD</span></code>. Remember that only PRO routers
send the link status message and that every router in the network must have the
same Link Status time period.</p>
<p>Another parameter that affects the Link Status message is
<code class="code docutils literal notranslate"><span class="pre">ZB_NWK_ROUTER_AGE_LIMIT</span></code> (default of 3). This
represents the number of Link Status periods that a router can remain in
a device’s neighbor list, without receiving a Link Status from that
device, before it becomes aged out of the list. If a device doesn’t received a
Link Status message from a neighbor within (<code class="code docutils literal notranslate"><span class="pre">ZB_NWK_ROUTER_AGE_LIMIT</span></code> *
<code class="code docutils literal notranslate"><span class="pre">ZB_NWK_LINK_STATUS_PERIOD</span></code>), the device will age the neighbor out and
assume that this neighbor is missing or that it’s an asynchronous link and not
use it.</p>
</div>
<div class="section" id="multicast-messages">
<h3>Multicast Messages<a class="headerlink" href="#multicast-messages" title="Permalink to this headline">¶</a></h3>
<p>This feature is a Zigbee PRO only feature.  This feature is similar to sending
to an APS Group, but at the network layer.</p>
<p>A multicast message is sent from a device to a group as a MAC broadcast
message, which includes a non-member radius field. The receiving device will
determine if it is part of that group. If it isn’t part of the group, then it
will decrement the non-member radius and rebroadcast. If it is part of the group,
then it will first set the non-member radius equal to the group radius, and then
rebroadcast the message. If the non-member radius is decremented to 0, the
message isn’t rebroadcast.</p>
<p>The difference between multicast and APS group messages can only be seen
in very large networks, where the non-member radius will limit the number
of hops away from the group.</p>
</div>
<div class="section" id="fragmentation">
<h3>Fragmentation<a class="headerlink" href="#fragmentation" title="Permalink to this headline">¶</a></h3>
<p>Message Fragmentation is a process where a large message – too large to
send in one APS packet – is broken down and transmitted as smaller
fragments. The fragments of the larger message are then reassembled by
the receiving device.</p>
<p>When APS Fragmentation is turned on, sending a data request with a
payload larger than a normal data request payload will automatically
trigger fragmentation.</p>
</div>
<div class="section" id="extended-pan-ids">
<span id="extended-pan-id"></span><h3>Extended PAN IDs<a class="headerlink" href="#extended-pan-ids" title="Permalink to this headline">¶</a></h3>
<p>By default, the 64-bit Extended PAN ID (EPID) is set to the device’s own IEEE address.
If a pre-determined EPID is required, the developer changes this in the project’s .syscfg file.</p>
</div>
<div class="section" id="rejoining-with-pre-commissioned-network-parameters">
<h3>Rejoining with Pre-Commissioned Network Parameters<a class="headerlink" href="#rejoining-with-pre-commissioned-network-parameters" title="Permalink to this headline">¶</a></h3>
<p>In previous Zigbee stacks, it was possible for a rejoining device to use
a pre-configured network address. As of today, the Base Device Behavior
specification has not addressed this topic (whether this is allowed or
not). TI encourages the use of the Base Device Behavior commissioning
methods described in <a class="reference internal" href="../zigbee/z-stack-overview.html#z-stack-overview-commissioning"><span class="std std-ref">Commissioning</span></a> for rejoining the network.</p>
</div>
</div>
</div>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2005-2024, Texas Instruments.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>
 <script type="text/javascript">
    $(document).ready(function() {
        $(".toggle > *").hide();
        $(".toggle .header").show();
        $(".toggle .header").click(function() {
            $(this).parent().children().not(".header").toggle(400);
            $(this).parent().children(".header").toggleClass("open");
        })
    });
</script>


</body>
</html>