<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>EventP.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="dir_dd8fa7f0a423552d37651735ac37558f.html">ti</a></li><li class="navelem"><a class="el" href="dir_15fb9a92674a5e15cac1f3112cfb19ae.html">drivers</a></li><li class="navelem"><a class="el" href="dir_fb2953259385de282595b9f3b684779b.html">dpl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">EventP.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Event Group support. </p>
<p>============================================================================</p>
<p>Events are a collection of bits with an application-defined meaning, typically used for messaging or synchronisation. A task may check the state of a set of bits or pend on an EventP object to react to changes when they are posted from another context.</p>
<p>Only one Task may pend on a single EventP object at any given time.</p>
<p>Events are synchronous in nature, meaning that a receiving task will block or pend while waiting for the events to occur. When the desired events are received, the pending task continues its execution, as it would after a call to Semaphore_pend(), for example.</p>
<p>EventP_pend is used to wait for events. The eventMask determine which event(s) must occur before returning from EventP_pend. The timeout parameter allows the task to wait until a timeout, wait indefinitely, or not wait at all. If waitForAll is true, the pend call will not return until all of the bits in eventMask are set. If it is false, any of the bits in eventMask will be returned. A return value of zero indicates that a timeout has occurred. A non-zero return value is the set of events that were active at the time the task was unblocked. Event bits that caused a return (either the whole eventMask or any individual bit, depending on waitForAll) will be cleared when EventP_pend returns. </p><hr/>
</div><div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for EventP.h:</div>
<div class="dyncontent">
<div class="center"><img src="_event_p_8h__incl.png" border="0" usemap="#_event_p_8h" alt=""/></div>
<map name="_event_p_8h" id="_event_p_8h">
</map>
</div>
</div>
<p><a href="_event_p_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_event_p___struct.html">EventP_Struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">EventP structure.  <a href="union_event_p___struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:aa17da81e032a4fd54a5cb534067fc362"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_event_p_8h.html#aa17da81e032a4fd54a5cb534067fc362">EventP_STRUCT_SIZE</a>&#160;&#160;&#160;(52)</td></tr>
<tr class="memdesc:aa17da81e032a4fd54a5cb534067fc362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes greater than or equal to the size of any RTOS Event object.  <a href="#aa17da81e032a4fd54a5cb534067fc362">More...</a><br /></td></tr>
<tr class="separator:aa17da81e032a4fd54a5cb534067fc362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4e2cd535297528eb21330667506f2ed"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_event_p_8h.html#af4e2cd535297528eb21330667506f2ed">EventP_WAIT_FOREVER</a>&#160;&#160;&#160;~(0)</td></tr>
<tr class="memdesc:af4e2cd535297528eb21330667506f2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait forever define.  <a href="#af4e2cd535297528eb21330667506f2ed">More...</a><br /></td></tr>
<tr class="separator:af4e2cd535297528eb21330667506f2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a392634539549d325240499ad68a20adb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_event_p_8h.html#a392634539549d325240499ad68a20adb">EventP_NO_WAIT</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="memdesc:a392634539549d325240499ad68a20adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">No wait define.  <a href="#a392634539549d325240499ad68a20adb">More...</a><br /></td></tr>
<tr class="separator:a392634539549d325240499ad68a20adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab6dad72c2d3d2ed52462fce1b3616130"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="union_event_p___struct.html">EventP_Struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_event_p_8h.html#ab6dad72c2d3d2ed52462fce1b3616130">EventP_Struct</a></td></tr>
<tr class="memdesc:ab6dad72c2d3d2ed52462fce1b3616130"><td class="mdescLeft">&#160;</td><td class="mdescRight">EventP structure.  <a href="#ab6dad72c2d3d2ed52462fce1b3616130">More...</a><br /></td></tr>
<tr class="separator:ab6dad72c2d3d2ed52462fce1b3616130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86669a618ff7edb0c175dccce3b2d70"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="union_event_p___struct.html">EventP_Struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a></td></tr>
<tr class="memdesc:ae86669a618ff7edb0c175dccce3b2d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque client reference to an instance of a EventP.  <a href="#ae86669a618ff7edb0c175dccce3b2d70">More...</a><br /></td></tr>
<tr class="separator:ae86669a618ff7edb0c175dccce3b2d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acc4c141f5278340bc2a95ff4f63c6e61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_event_p_8h.html#acc4c141f5278340bc2a95ff4f63c6e61">EventP_create</a> (void)</td></tr>
<tr class="memdesc:acc4c141f5278340bc2a95ff4f63c6e61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an EventP, allocating memory on the heap.  <a href="#acc4c141f5278340bc2a95ff4f63c6e61">More...</a><br /></td></tr>
<tr class="separator:acc4c141f5278340bc2a95ff4f63c6e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a64fbc29196c2df065395f0a3c60a95"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_event_p_8h.html#a4a64fbc29196c2df065395f0a3c60a95">EventP_delete</a> (<a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a> handle)</td></tr>
<tr class="memdesc:a4a64fbc29196c2df065395f0a3c60a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to delete an EventP.  <a href="#a4a64fbc29196c2df065395f0a3c60a95">More...</a><br /></td></tr>
<tr class="separator:a4a64fbc29196c2df065395f0a3c60a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67450f13c6d2850aefe1bae8dd4ddd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_event_p_8h.html#ad67450f13c6d2850aefe1bae8dd4ddd5">EventP_construct</a> (<a class="el" href="union_event_p___struct.html">EventP_Struct</a> *obj)</td></tr>
<tr class="memdesc:ad67450f13c6d2850aefe1bae8dd4ddd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an EventP, using statically allocated memory.  <a href="#ad67450f13c6d2850aefe1bae8dd4ddd5">More...</a><br /></td></tr>
<tr class="separator:ad67450f13c6d2850aefe1bae8dd4ddd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a15a5b398c85b65f9ac5a2e447df14d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_event_p_8h.html#a8a15a5b398c85b65f9ac5a2e447df14d">EventP_destruct</a> (<a class="el" href="union_event_p___struct.html">EventP_Struct</a> *obj)</td></tr>
<tr class="memdesc:a8a15a5b398c85b65f9ac5a2e447df14d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to destruct an EventP.  <a href="#a8a15a5b398c85b65f9ac5a2e447df14d">More...</a><br /></td></tr>
<tr class="separator:a8a15a5b398c85b65f9ac5a2e447df14d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab49cad4aa76c5b9b78f91afaa1e1acc5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_event_p_8h.html#ab49cad4aa76c5b9b78f91afaa1e1acc5">EventP_pend</a> (<a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a> event, uint32_t eventMask, bool waitForAll, uint32_t timeout)</td></tr>
<tr class="memdesc:ab49cad4aa76c5b9b78f91afaa1e1acc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the events listed in eventMask.  <a href="#ab49cad4aa76c5b9b78f91afaa1e1acc5">More...</a><br /></td></tr>
<tr class="separator:ab49cad4aa76c5b9b78f91afaa1e1acc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e4ffe447fc2a43ead540afab9862edd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_event_p_8h.html#a8e4ffe447fc2a43ead540afab9862edd">EventP_post</a> (<a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a> event, uint32_t eventMask)</td></tr>
<tr class="memdesc:a8e4ffe447fc2a43ead540afab9862edd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Post events to an event object.  <a href="#a8e4ffe447fc2a43ead540afab9862edd">More...</a><br /></td></tr>
<tr class="separator:a8e4ffe447fc2a43ead540afab9862edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96b6ddc8ffec6136ef08e3e8772bbcd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_event_p_8h.html#a96b6ddc8ffec6136ef08e3e8772bbcd9">EventP_clear</a> (<a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a> event, uint32_t eventMask)</td></tr>
<tr class="memdesc:a96b6ddc8ffec6136ef08e3e8772bbcd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear events from an event object.  <a href="#a96b6ddc8ffec6136ef08e3e8772bbcd9">More...</a><br /></td></tr>
<tr class="separator:a96b6ddc8ffec6136ef08e3e8772bbcd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37cbde3a07725b4e93baad5888370766"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_event_p_8h.html#a37cbde3a07725b4e93baad5888370766">EventP_get</a> (<a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a> event)</td></tr>
<tr class="memdesc:a37cbde3a07725b4e93baad5888370766"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current events from an event object.  <a href="#a37cbde3a07725b4e93baad5888370766">More...</a><br /></td></tr>
<tr class="separator:a37cbde3a07725b4e93baad5888370766"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="aa17da81e032a4fd54a5cb534067fc362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17da81e032a4fd54a5cb534067fc362">&sect;&nbsp;</a></span>EventP_STRUCT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EventP_STRUCT_SIZE&#160;&#160;&#160;(52)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bytes greater than or equal to the size of any RTOS Event object. </p>
<p>BIOS 6.x: 20 BIOS 7.x: 20 FreeRTOS: 52 </p>

</div>
</div>
<a id="af4e2cd535297528eb21330667506f2ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4e2cd535297528eb21330667506f2ed">&sect;&nbsp;</a></span>EventP_WAIT_FOREVER</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EventP_WAIT_FOREVER&#160;&#160;&#160;~(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait forever define. </p>

</div>
</div>
<a id="a392634539549d325240499ad68a20adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a392634539549d325240499ad68a20adb">&sect;&nbsp;</a></span>EventP_NO_WAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EventP_NO_WAIT&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No wait define. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ab6dad72c2d3d2ed52462fce1b3616130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6dad72c2d3d2ed52462fce1b3616130">&sect;&nbsp;</a></span>EventP_Struct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="union_event_p___struct.html">EventP_Struct</a>  <a class="el" href="union_event_p___struct.html">EventP_Struct</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>EventP structure. </p>
<p>Opaque structure that should be large enough to hold any of the RTOS specific EventP objects. </p>

</div>
</div>
<a id="ae86669a618ff7edb0c175dccce3b2d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae86669a618ff7edb0c175dccce3b2d70">&sect;&nbsp;</a></span>EventP_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="union_event_p___struct.html">EventP_Struct</a>* <a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque client reference to an instance of a EventP. </p>
<p>A EventP_Handle returned from create or construct represents that instance. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acc4c141f5278340bc2a95ff4f63c6e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4c141f5278340bc2a95ff4f63c6e61">&sect;&nbsp;</a></span>EventP_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a> EventP_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create an EventP, allocating memory on the heap. </p>
<p>EventP_create creates a new event object. EventP_create returns the handle of the new task object or NULL if the event could not be created.</p>
<p>When created, no bits of an event are set. For FreeRTOS, configSUPPORT_DYNAMIC_ALLOCATION also has to be set to 1 in FreeRTOSConfig.h. See 'Configuration with FreeRTOS' in the Core SDK User's Guide for how to do this.</p>
<p>This API cannot be called from interrupt contexts.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EventP</td><td>handle (NULL on failure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4a64fbc29196c2df065395f0a3c60a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a64fbc29196c2df065395f0a3c60a95">&sect;&nbsp;</a></span>EventP_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EventP_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to delete an EventP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>A EventP_Handle returned from EventP_create </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad67450f13c6d2850aefe1bae8dd4ddd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67450f13c6d2850aefe1bae8dd4ddd5">&sect;&nbsp;</a></span>EventP_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a> EventP_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_event_p___struct.html">EventP_Struct</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an EventP, using statically allocated memory. </p>
<p>EventP_construct creates a new event object. EventP_construct returns the handle of the new task object or NULL if the event could not be created.</p>
<p>When created, no bits of an event are set. For FreeRTOS, configSUPPORT_STATIC_ALLOCATION also has to be set to 1 in FreeRTOSConfig.h. See 'Configuration with FreeRTOS' in the Core SDK User's Guide for how to do this.</p>
<p>This API cannot be called from interrupt contexts.</p>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">EventP</td><td>handle (NULL on failure) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8a15a5b398c85b65f9ac5a2e447df14d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a15a5b398c85b65f9ac5a2e447df14d">&sect;&nbsp;</a></span>EventP_destruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EventP_destruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_event_p___struct.html">EventP_Struct</a> *&#160;</td>
          <td class="paramname"><em>obj</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to destruct an EventP. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to a <a class="el" href="union_event_p___struct.html" title="EventP structure. ">EventP_Struct</a> object that was passed to <a class="el" href="_event_p_8h.html#ad67450f13c6d2850aefe1bae8dd4ddd5" title="Construct an EventP, using statically allocated memory. ">EventP_construct()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="ab49cad4aa76c5b9b78f91afaa1e1acc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab49cad4aa76c5b9b78f91afaa1e1acc5">&sect;&nbsp;</a></span>EventP_pend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EventP_pend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>waitForAll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wait for the events listed in eventMask. </p>
<p>EventP_pend is used to wait for events. The eventMask determine which event(s) must occur before returning from EventP_pend. The timeout parameter allows the task to wait until a timeout, wait indefinitely, or not wait at all. If waitForAll is true, the pend call will not return until all of the bits in eventMask are set. If it is false, any of the bits in eventMask will be returned. A return value of zero indicates that a timeout has occurred. A non-zero return value is the set of events in the eventMask that were active at the time the task was unblocked.</p>
<p>Event bits that caused a return (either the whole eventMask or any individual bit, depending on waitForAll) will be cleared when EventP_pend returns.</p>
<p>A timeout value of EventP_WAIT_FOREVER causes the task to wait indefinitely for matching events to be posted. A timeout value of EventP_NO_WAIT causes EventP_pend to return immediately.</p>
<p>This API cannot be called from interrupt contexts.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle </td></tr>
    <tr><td class="paramname">eventMask</td><td>Match against the events in this bitmask. For FreeRTOS, only the 24 least significant bits in the event mask may be set, meaning the maximum allowed value for FreeRTOS is 0x00FFFFFF. </td></tr>
    <tr><td class="paramname">waitForAll</td><td>If true, only return when all matching bits are set </td></tr>
    <tr><td class="paramname">timeout</td><td>Return after this many ClockP ticks, even if there is no match</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">A</td><td>bitmask containing all consumed events, or zero on timeout. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8e4ffe447fc2a43ead540afab9862edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e4ffe447fc2a43ead540afab9862edd">&sect;&nbsp;</a></span>EventP_post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EventP_post </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Post events to an event object. </p>
<p><a class="el" href="_event_p_8h.html#a8e4ffe447fc2a43ead540afab9862edd" title="Post events to an event object. ">EventP_post()</a> is used to signal events. If a task is waiting for the event and the event conditions are met, <a class="el" href="_event_p_8h.html#a8e4ffe447fc2a43ead540afab9862edd" title="Post events to an event object. ">EventP_post()</a> unblocks the task. If no tasks are waiting, <a class="el" href="_event_p_8h.html#a8e4ffe447fc2a43ead540afab9862edd" title="Post events to an event object. ">EventP_post()</a> simply registers the event with the event object and returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle </td></tr>
    <tr><td class="paramname">eventMask</td><td>Mask of eventIds to post (this must be non-zero). For FreeRTOS, only the 24 least significant bits in the event mask may be set, meaning the maximum allowed value for FreeRTOS is 0x00FFFFFF. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a96b6ddc8ffec6136ef08e3e8772bbcd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96b6ddc8ffec6136ef08e3e8772bbcd9">&sect;&nbsp;</a></span>EventP_clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void EventP_clear </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a>&#160;</td>
          <td class="paramname"><em>event</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>eventMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear events from an event object. </p>
<p>Clears the bits in eventMask from the EventP.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle </td></tr>
    <tr><td class="paramname">eventMask</td><td>Mask of eventIds to clear (this must be non-zero). For FreeRTOS, only the 24 least significant bits in the event mask may be set, meaning the maximum allowed value for FreeRTOS is 0x00FFFFFF. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37cbde3a07725b4e93baad5888370766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37cbde3a07725b4e93baad5888370766">&sect;&nbsp;</a></span>EventP_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t EventP_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_event_p_8h.html#ae86669a618ff7edb0c175dccce3b2d70">EventP_Handle</a>&#160;</td>
          <td class="paramname"><em>event</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current events from an event object. </p>
<p>Returns the currently active events in an EventP without clearing them.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">event</td><td>Event handle</td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">Currently</td><td>active events </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2024</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
