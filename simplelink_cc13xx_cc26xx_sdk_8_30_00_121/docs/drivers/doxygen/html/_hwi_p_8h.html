<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>HwiP.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="dir_dd8fa7f0a423552d37651735ac37558f.html">ti</a></li><li class="navelem"><a class="el" href="dir_15fb9a92674a5e15cac1f3112cfb19ae.html">drivers</a></li><li class="navelem"><a class="el" href="dir_fb2953259385de282595b9f3b684779b.html">dpl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">HwiP.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Hardware Interrupt module for the RTOS Porting Interface. </p>
<p>============================================================================</p>
<p>The <a class="el" href="_hwi_p_8h.html#aac47ffab62f7d25d736b58e40be17425" title="Function to disable interrupts to enter a critical region. ">HwiP_disable()</a>/<a class="el" href="_hwi_p_8h.html#a979cdfbd9993f6c5eedef8570efbd62e" title="Function to restore interrupts to exit a critical region. ">HwiP_restore()</a> APIs can be called recursively. The order of the <a class="el" href="_hwi_p_8h.html#a979cdfbd9993f6c5eedef8570efbd62e" title="Function to restore interrupts to exit a critical region. ">HwiP_restore()</a> calls, must be in reversed order. For example: </p><div class="fragment"><div class="line">uintptr_t key1, key2;</div><div class="line">key1 = <a class="code" href="_hwi_p_8h.html#aac47ffab62f7d25d736b58e40be17425">HwiP_disable</a>();</div><div class="line">key2 = <a class="code" href="_hwi_p_8h.html#aac47ffab62f7d25d736b58e40be17425">HwiP_disable</a>();</div><div class="line"><a class="code" href="_hwi_p_8h.html#a979cdfbd9993f6c5eedef8570efbd62e">HwiP_restore</a>(key2);</div><div class="line"><a class="code" href="_hwi_p_8h.html#a979cdfbd9993f6c5eedef8570efbd62e">HwiP_restore</a>(key1);</div></div><!-- fragment --><p><a class="anchor" id="ti_drivers_HwiP_Cross_Platform_Considerations"></a></p><h2>Cross-platform Considerations</h2>
<p>The following sections highlight some important items to consider when using the HwiP DPL. Due to the nature and intention of different operating systems, the HwiP DPL implementation may differ depending on the underlying platform and operating system.</p>
<h3>Arm Cortex-M Interrupt Priorities</h3>
<p>On Arm Cortex-M platforms, the highest logical interrupt priority has the lowest numerical value. That is, 0 is the highest interrupt priority (interrupt level 0 has the highest urgency). The number of interrupt priorities is given by the number of interrupt priority bits implemented, which is vendor-specific.</p>
<p>For example:</p>
<table class="doxtable">
<tr>
<th>Device Family </th><th>Architecture </th><th>Priority Bits </th><th>Priority Levels  </th></tr>
<tr>
<td>CC23X0 </td><td>Armv6-m </td><td>2 </td><td>4 (0-3) </td></tr>
<tr>
<td>CC13X2_CC26X2 </td><td>Armv7-m </td><td>3 </td><td>8 (0-7) </td></tr>
<tr>
<td>CC13X4_CC26X4 </td><td>Armv8-m </td><td>3 </td><td>8 (0-7) </td></tr>
<tr>
<td>CC27XX </td><td>Armv8-m </td><td>4 </td><td>16 (0-15) </td></tr>
</table>
<p>On Arm Cortex-M platforms, interrupt priority values are stored in the most significant bits of the 8-bit interrupt priority registers. For example, with 3 interrupt priority bits implemented, interrupt priority level 2 (0b010) is represented in the interrupt priority registers as 0b010 &lt;&lt; (8-3) = 0x40. This is automatically handled by SysConfig, but may cause some confusion, for example, when inspecting the raw value of the <a class="el" href="struct_hwi_p___params.html#ac4977525e0bda265e8bbe2980dc16eda">HwiP_Params.priority</a> field or the Cortex-M interrupt priority registers.</p>
<p>See <a href="http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html">http://www.FreeRTOS.org/RTOS-Cortex-M3-M4.html</a> for more details.</p>
<p>Arm Cortex-M devices may support 2 methods for masking interrupts</p><ul>
<li><code>PRIMASK</code> disables all interrupt levels indiscriminately (with the exception of non-maskable interrupts).</li>
<li><code>BASEPRI</code> disables interrupts with priority equal to or lower than a certain level. Software can set <code>BASEPRI</code> to a priority level between 1 (second highest priority) and the maximum supported priority level (lowest priority). This means that interrupt priority level 0 cannot be masked using <code>BASEPRI</code>.</li>
</ul>
<p>The table gives an overview of what interrupt masking controls the different Arm platforms support:</p>
<table class="doxtable">
<tr>
<th>Architecture </th><th align="center">PRIMASK </th><th align="center">BASEPRI  </th></tr>
<tr>
<td>Armv6-m </td><td align="center">Yes </td><td align="center">No </td></tr>
<tr>
<td>Armv7-m </td><td align="center">Yes </td><td align="center">Yes </td></tr>
<tr>
<td>Armv8-m </td><td align="center">Yes </td><td align="center">Yes </td></tr>
</table>
<h3>FreeRTOS</h3>
<p>On Cortex-M platforms that support <code>BASEPRI</code>, the FreeRTOS kernel does not completely disable interrupts even inside critical sections. This is achieved by these FreeRTOS configurations:</p>
<ul>
<li><code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> defines the highest logical priority at which FreeRTOS kernel API calls can be made.</li>
<li><code>configKERNEL_INTERRUPT_PRIORITY</code> sets the priority of the FreeRTOS kernel itself, usually the lowest logical priority possible.</li>
</ul>
<p>This permits a fully nested model where higher-priority interrupts can preempt lower-priority ones. However, interrupts that require FreeRTOS API calls must adhere to the <code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code> limit to avoid corrupting kernel data.</p>
<p>See <a href="https://www.freertos.org/a00110.html#kernel_priority">https://www.freertos.org/a00110.html#kernel_priority</a> for more details.</p>
<ul>
<li><a class="el" href="_hwi_p_8h.html#aac47ffab62f7d25d736b58e40be17425" title="Function to disable interrupts to enter a critical region. ">HwiP_disable()</a>: sets <code>BASEPRI</code> to <code>configMAX_SYSCALL_INTERRUPT_PRIORITY</code>. Returns original <code>BASEPRI</code>.</li>
<li><a class="el" href="_hwi_p_8h.html#a979cdfbd9993f6c5eedef8570efbd62e" title="Function to restore interrupts to exit a critical region. ">HwiP_restore()</a> sets <code>BASEPRI</code> to 0 (no interrupts are masked).</li>
</ul>
<h3>TI-RTOS</h3>
<p>TI-RTOS behaves similar to FreeRTOS, meaning that on Cortex-M platforms that support <code>BASEPRI</code>, the TI-RTOS kernel does not completely disable interrupts even inside critical sections.</p>
<ul>
<li><a class="el" href="_hwi_p_8h.html#aac47ffab62f7d25d736b58e40be17425" title="Function to disable interrupts to enter a critical region. ">HwiP_disable()</a> sets <code>BASEPRI</code> to <code>Hwi_disablePriority</code>. Returns original <code>BASEPRI</code>.</li>
<li><a class="el" href="_hwi_p_8h.html#a979cdfbd9993f6c5eedef8570efbd62e" title="Function to restore interrupts to exit a critical region. ">HwiP_restore()</a> sets <code>BASEPRI</code> to the provided argument value.</li>
</ul>
<p>See TI-RTOS Hwi documentation for more details.</p>
<h3>NoRTOS</h3>
<ul>
<li><a class="el" href="_hwi_p_8h.html#aac47ffab62f7d25d736b58e40be17425" title="Function to disable interrupts to enter a critical region. ">HwiP_disable()</a> disables all interrupt levels indiscriminately.</li>
<li><a class="el" href="_hwi_p_8h.html#a979cdfbd9993f6c5eedef8570efbd62e" title="Function to restore interrupts to exit a critical region. ">HwiP_restore()</a> globally enables all interrupts. <hr/>
</li>
</ul>
</div><div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for HwiP.h:</div>
<div class="dyncontent">
<div class="center"><img src="_hwi_p_8h__incl.png" border="0" usemap="#_hwi_p_8h" alt=""/></div>
<map name="_hwi_p_8h" id="_hwi_p_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="_hwi_p_8h__dep__incl.png" border="0" usemap="#_hwi_p_8hdep" alt=""/></div>
<map name="_hwi_p_8hdep" id="_hwi_p_8hdep">
<area shape="rect" id="node2" href="_a_d_c_buf_c_c26_x2_8h.html" title="ADCBuf driver implementation for a CC26X2 analog&#45;to&#45;digital converter. " alt="" coords="742,379,877,405"/>
<area shape="rect" id="node3" href="_a_d_c_buf_c_c26_x_x_8h.html" title="ADCBuf driver implementation for a CC26XX analog&#45;to&#45;digital converter. " alt="" coords="581,379,717,405"/>
<area shape="rect" id="node4" href="_a_e_s_c_c_m_c_c26_x4_8h.html" title="AESCCM driver implementation for the CC26X4 family. " alt="" coords="939,304,1079,331"/>
<area shape="rect" id="node5" href="_a_e_s_c_c_m_c_c26_x_x_8h.html" title="AESCCM driver implementation for the CC26XX family. " alt="" coords="1917,304,2059,331"/>
<area shape="rect" id="node6" href="_a_e_s_e_c_b_c_c26_x_x_8h.html" title="AESECB driver implementation for the CC26XX family. " alt="" coords="2083,304,2221,331"/>
<area shape="rect" id="node7" href="_a_e_s_g_c_m_c_c26_x4_8h.html" title="AESGCM driver implementation for the CC26X4 family. " alt="" coords="2296,304,2437,331"/>
<area shape="rect" id="node8" href="_a_e_s_g_c_m_c_c26_x_x_8h.html" title="AESGCM driver implementation for the CC26XX family. " alt="" coords="2462,304,2605,331"/>
<area shape="rect" id="node9" href="_crypto_resource_c_c26_x_x_8h.html" title="Shared resources to arbitrate access to the keyStore, AES, and SHA2 engine. " alt="" coords="3160,80,3349,107"/>
<area shape="rect" id="node10" href="_e_c_d_h_c_c26_x2_8h.html" title="ECDH driver implementation for the CC26X2 family. " alt="" coords="2629,304,2752,331"/>
<area shape="rect" id="node11" href="_e_c_d_s_a_c_c26_x2_8h.html" title="ECDSA driver implementation for the CC26X2 family. " alt="" coords="2596,379,2727,405"/>
<area shape="rect" id="node12" href="_i2_s_c_c26_x_x_8h.html" title="I2S driver implementation for a CC26XX I2S controller. " alt="" coords="2776,304,2883,331"/>
<area shape="rect" id="node13" href="_p_d_m_c_c26_x_x_8h.html" title="PDM driver implementation for a CC26XX PDM controller. " alt="" coords="529,304,645,331"/>
<area shape="rect" id="node14" href="_p_d_m_c_c26_x_x__util_8h.html" title="PDM utility includes helper functions for configuring the CC26XX I2S controller. " alt="" coords="720,304,864,331"/>
<area shape="rect" id="node15" href="_power_c_c26_x2_8h.html" title="Power manager interface for CC26X2. " alt="" coords="1372,80,1497,107"/>
<area shape="rect" id="node16" href="_power_c_c26_x_x_8h.html" title="Power manager interface for CC26XX/CC13XX. " alt="" coords="1371,155,1498,181"/>
<area shape="rect" id="node20" href="_s_p_i_c_c26_x2_d_m_a_8h.html" title="SPI driver implementation for a CC26XX SPI controller using the UDMA controller. " alt="" coords="1660,379,1796,405"/>
<area shape="rect" id="node21" href="_s_p_i_c_c26_x4_d_m_a_8h.html" title="SPI driver implementation for a CC26X4 SPI controller using the UDMA controller. " alt="" coords="2005,379,2141,405"/>
<area shape="rect" id="node25" href="_timer_8h.html" title="Timer driver. " alt="" coords="114,304,185,331"/>
<area shape="rect" id="node28" href="_t_r_n_g_c_c26_x_x_8h.html" title="TRNG driver implementation for the CC26XX family. " alt="" coords="3059,304,3181,331"/>
<area shape="rect" id="node31" href="_u_a_r_t2_8h.html" title="PRELIMINARY UART driver interface " alt="" coords="3216,304,3293,331"/>
<area shape="rect" id="node35" href="_g_p_timer_c_c26_x_x_8h.html" title="GPTimer driver implementation for CC26XX/CC13XX. " alt="" coords="209,304,351,331"/>
<area shape="rect" id="node37" href="_watchdog_c_c26_x4_8h.html" title="Watchdog driver implementation for CC13X4/CC26X4. " alt="" coords="3373,80,3523,107"/>
<area shape="rect" id="node38" href="_watchdog_c_c26_x_x_8h.html" title="Watchdog driver implementation for CC13XX/CC26XX. " alt="" coords="3547,80,3698,107"/>
<area shape="rect" id="node17" href="_a_d_c_c_c26_x_x_8h.html" title="ADC driver implementation for the ADC peripheral on CC26XX. " alt="" coords="1104,304,1219,331"/>
<area shape="rect" id="node18" href="_d_a_c_c_c26_x2_8h.html" title="DAC driver implementation for the DAC peripheral on CC26X2. " alt="" coords="1243,304,1357,331"/>
<area shape="rect" id="node19" href="_u_d_m_a_c_c26_x_x_8h.html" title="UDMACC26XX driver implementation. " alt="" coords="1614,304,1741,331"/>
<area shape="rect" id="node23" href="_i2_c_c_c26_x_x_8h.html" title="I2C driver implementation for a CC26XX I2C controller. " alt="" coords="1381,304,1488,331"/>
<area shape="rect" id="node24" href="_power_8h.html" title="Power Manager. " alt="" coords="1590,229,1663,256"/>
<area shape="rect" id="node22" href="_u_a_r_t2_c_c26_x2_8h.html" title="UART driver implementation for a CC26X2 UART controller. " alt="" coords="2751,379,2879,405"/>
<area shape="rect" id="node26" href="_timer_c_c26_x_x_8h.html" title="Timer driver interface for CC26XX devices. " alt="" coords="153,379,277,405"/>
<area shape="rect" id="node27" href="_timer_support_8h.html" title="Holder of common helper functions for the Timer driver. " alt="" coords="5,379,128,405"/>
<area shape="rect" id="node29" href="_e_c_d_s_a_c_c26_x1_8h.html" title="ECDSA driver implementation for the CC26X1 family. " alt="" coords="2903,379,3033,405"/>
<area shape="rect" id="node30" href="_r_n_g_c_c26_x_x_8h.html" title="RNG driver implementation for the CC26XX family. " alt="" coords="3057,379,3172,405"/>
<area shape="rect" id="node32" href="_u_a_r_t2_support_8h.html" title="Holder of common helper functions for the UART driver. " alt="" coords="3197,379,3323,405"/>
<area shape="rect" id="node33" href="_log_sink_u_a_r_t_8h.html" title="PRELIMINARY LogSinkUART interface " alt="" coords="3347,379,3466,405"/>
<area shape="rect" id="node34" href="_display_uart2_8h.html" title="Display.h implementation for UART output. " alt="" coords="3490,379,3609,405"/>
<area shape="rect" id="node36" href="_p_w_m_timer_c_c26_x_x_8h.html" title="PWM driver implementation for CC26XX/CC13XX. " alt="" coords="301,379,459,405"/>
</map>
</div>
</div>
<p><a href="_hwi_p_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_hwi_p___struct.html">HwiP_Struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">HwiP structure.  <a href="union_hwi_p___struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_hwi_p___params.html">HwiP_Params</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic HwiP Parameters.  <a href="struct_hwi_p___params.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a1fca150e7b36e480b092e0d9cbbb8721"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a1fca150e7b36e480b092e0d9cbbb8721">HwiP_STRUCT_SIZE</a>&#160;&#160;&#160;(28)</td></tr>
<tr class="memdesc:a1fca150e7b36e480b092e0d9cbbb8721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of bytes greater than or equal to the size of any RTOS HwiP object.  <a href="#a1fca150e7b36e480b092e0d9cbbb8721">More...</a><br /></td></tr>
<tr class="separator:a1fca150e7b36e480b092e0d9cbbb8721"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3ba69ca21548025e8d8babedd7ae2ea1"><td class="memItemLeft" align="right" valign="top">typedef union <a class="el" href="union_hwi_p___struct.html">HwiP_Struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a3ba69ca21548025e8d8babedd7ae2ea1">HwiP_Struct</a></td></tr>
<tr class="memdesc:a3ba69ca21548025e8d8babedd7ae2ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">HwiP structure.  <a href="#a3ba69ca21548025e8d8babedd7ae2ea1">More...</a><br /></td></tr>
<tr class="separator:a3ba69ca21548025e8d8babedd7ae2ea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd325ff62af296374efc6d317f5e368"><td class="memItemLeft" align="right" valign="top">typedef void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a7dd325ff62af296374efc6d317f5e368">HwiP_Handle</a></td></tr>
<tr class="memdesc:a7dd325ff62af296374efc6d317f5e368"><td class="mdescLeft">&#160;</td><td class="mdescRight">Opaque client reference to an instance of a HwiP.  <a href="#a7dd325ff62af296374efc6d317f5e368">More...</a><br /></td></tr>
<tr class="separator:a7dd325ff62af296374efc6d317f5e368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53a36fe33e22847927ceddbb63fb50c7"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a53a36fe33e22847927ceddbb63fb50c7">HwiP_Fxn</a>) (uintptr_t arg)</td></tr>
<tr class="memdesc:a53a36fe33e22847927ceddbb63fb50c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prototype for the entry function for a hardware interrupt.  <a href="#a53a36fe33e22847927ceddbb63fb50c7">More...</a><br /></td></tr>
<tr class="separator:a53a36fe33e22847927ceddbb63fb50c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8f508a9a62c31a942ffc9438f53dd258"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a8f508a9a62c31a942ffc9438f53dd258">HwiP_Status</a> { <a class="el" href="_hwi_p_8h.html#a8f508a9a62c31a942ffc9438f53dd258a96e82ebb87c2c36bba1fdd072fcec2f9">HwiP_OK</a> = 0, 
<a class="el" href="_hwi_p_8h.html#a8f508a9a62c31a942ffc9438f53dd258aa0988bb08bdcf17a219385320e200000">HwiP_FAILURE</a> = -1
 }<tr class="memdesc:a8f508a9a62c31a942ffc9438f53dd258"><td class="mdescLeft">&#160;</td><td class="mdescRight">Status codes for HwiP APIs.  <a href="_hwi_p_8h.html#a8f508a9a62c31a942ffc9438f53dd258">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a8f508a9a62c31a942ffc9438f53dd258"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9392b32717002e9447bd84181f323adb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_hwi_p_8h.html#a7dd325ff62af296374efc6d317f5e368">HwiP_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a9392b32717002e9447bd84181f323adb">HwiP_construct</a> (<a class="el" href="union_hwi_p___struct.html">HwiP_Struct</a> *hwiP, int interruptNum, <a class="el" href="_hwi_p_8h.html#a53a36fe33e22847927ceddbb63fb50c7">HwiP_Fxn</a> hwiFxn, <a class="el" href="struct_hwi_p___params.html">HwiP_Params</a> *<a class="el" href="_driver___init_8h.html#af93f10d4f7393a01dff58c92f91d8cbc">params</a>)</td></tr>
<tr class="memdesc:a9392b32717002e9447bd84181f323adb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to construct a hardware interrupt object.  <a href="#a9392b32717002e9447bd84181f323adb">More...</a><br /></td></tr>
<tr class="separator:a9392b32717002e9447bd84181f323adb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad55b2c5937f748d643f8c3ffdeeabea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#ad55b2c5937f748d643f8c3ffdeeabea2">HwiP_destruct</a> (<a class="el" href="union_hwi_p___struct.html">HwiP_Struct</a> *hwiP)</td></tr>
<tr class="memdesc:ad55b2c5937f748d643f8c3ffdeeabea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to destruct a hardware interrupt object.  <a href="#ad55b2c5937f748d643f8c3ffdeeabea2">More...</a><br /></td></tr>
<tr class="separator:ad55b2c5937f748d643f8c3ffdeeabea2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8d9c04a4f255f272ca690b25d59c7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#afe8d9c04a4f255f272ca690b25d59c7e">HwiP_clearInterrupt</a> (int interruptNum)</td></tr>
<tr class="memdesc:afe8d9c04a4f255f272ca690b25d59c7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to clear a single interrupt.  <a href="#afe8d9c04a4f255f272ca690b25d59c7e">More...</a><br /></td></tr>
<tr class="separator:afe8d9c04a4f255f272ca690b25d59c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d80df47f0bdcbb6e562ee7b96a40af5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="_hwi_p_8h.html#a7dd325ff62af296374efc6d317f5e368">HwiP_Handle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a3d80df47f0bdcbb6e562ee7b96a40af5">HwiP_create</a> (int interruptNum, <a class="el" href="_hwi_p_8h.html#a53a36fe33e22847927ceddbb63fb50c7">HwiP_Fxn</a> hwiFxn, <a class="el" href="struct_hwi_p___params.html">HwiP_Params</a> *<a class="el" href="_driver___init_8h.html#af93f10d4f7393a01dff58c92f91d8cbc">params</a>)</td></tr>
<tr class="memdesc:a3d80df47f0bdcbb6e562ee7b96a40af5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to create an interrupt on CortexM devices.  <a href="#a3d80df47f0bdcbb6e562ee7b96a40af5">More...</a><br /></td></tr>
<tr class="separator:a3d80df47f0bdcbb6e562ee7b96a40af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2e1c500e845723be6cd6e4caa58d6d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#ab2e1c500e845723be6cd6e4caa58d6d7">HwiP_delete</a> (<a class="el" href="_hwi_p_8h.html#a7dd325ff62af296374efc6d317f5e368">HwiP_Handle</a> handle)</td></tr>
<tr class="memdesc:ab2e1c500e845723be6cd6e4caa58d6d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to delete an interrupt on CortexM devices.  <a href="#ab2e1c500e845723be6cd6e4caa58d6d7">More...</a><br /></td></tr>
<tr class="separator:ab2e1c500e845723be6cd6e4caa58d6d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac47ffab62f7d25d736b58e40be17425"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#aac47ffab62f7d25d736b58e40be17425">HwiP_disable</a> (void)</td></tr>
<tr class="memdesc:aac47ffab62f7d25d736b58e40be17425"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to disable interrupts to enter a critical region.  <a href="#aac47ffab62f7d25d736b58e40be17425">More...</a><br /></td></tr>
<tr class="separator:aac47ffab62f7d25d736b58e40be17425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a0a63fd819bbcb31064a60fc901629"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a89a0a63fd819bbcb31064a60fc901629">HwiP_enable</a> (void)</td></tr>
<tr class="memdesc:a89a0a63fd819bbcb31064a60fc901629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to enable interrupts.  <a href="#a89a0a63fd819bbcb31064a60fc901629">More...</a><br /></td></tr>
<tr class="separator:a89a0a63fd819bbcb31064a60fc901629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab29f4a0e277d336338900c07151325"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a2ab29f4a0e277d336338900c07151325">HwiP_disableInterrupt</a> (int interruptNum)</td></tr>
<tr class="memdesc:a2ab29f4a0e277d336338900c07151325"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to disable a single interrupt.  <a href="#a2ab29f4a0e277d336338900c07151325">More...</a><br /></td></tr>
<tr class="separator:a2ab29f4a0e277d336338900c07151325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f70cf8be574453b13dd9bfa4c8da26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a31f70cf8be574453b13dd9bfa4c8da26">HwiP_enableInterrupt</a> (int interruptNum)</td></tr>
<tr class="memdesc:a31f70cf8be574453b13dd9bfa4c8da26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to enable a single interrupt.  <a href="#a31f70cf8be574453b13dd9bfa4c8da26">More...</a><br /></td></tr>
<tr class="separator:a31f70cf8be574453b13dd9bfa4c8da26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06403da6ca0ed381d658fd4d54a3d294"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a06403da6ca0ed381d658fd4d54a3d294">HwiP_inISR</a> (void)</td></tr>
<tr class="memdesc:a06403da6ca0ed381d658fd4d54a3d294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to return a status based on whether it is in an interrupt context.  <a href="#a06403da6ca0ed381d658fd4d54a3d294">More...</a><br /></td></tr>
<tr class="separator:a06403da6ca0ed381d658fd4d54a3d294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a13fc52abcff27467ca5b5ff8a6f27"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a90a13fc52abcff27467ca5b5ff8a6f27">HwiP_interruptsEnabled</a> (void)</td></tr>
<tr class="memdesc:a90a13fc52abcff27467ca5b5ff8a6f27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to determine whether interrupts are currently enabled.  <a href="#a90a13fc52abcff27467ca5b5ff8a6f27">More...</a><br /></td></tr>
<tr class="separator:a90a13fc52abcff27467ca5b5ff8a6f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f02161b1837b41f08ba064f1001045"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a33f02161b1837b41f08ba064f1001045">HwiP_Params_init</a> (<a class="el" href="struct_hwi_p___params.html">HwiP_Params</a> *<a class="el" href="_driver___init_8h.html#af93f10d4f7393a01dff58c92f91d8cbc">params</a>)</td></tr>
<tr class="memdesc:a33f02161b1837b41f08ba064f1001045"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize params structure to default values.  <a href="#a33f02161b1837b41f08ba064f1001045">More...</a><br /></td></tr>
<tr class="separator:a33f02161b1837b41f08ba064f1001045"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8ab58bc06face6a1ca248352a22e1d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#ab8ab58bc06face6a1ca248352a22e1d0">HwiP_plug</a> (int interruptNum, void *fxn)</td></tr>
<tr class="memdesc:ab8ab58bc06face6a1ca248352a22e1d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to plug an interrupt vector.  <a href="#ab8ab58bc06face6a1ca248352a22e1d0">More...</a><br /></td></tr>
<tr class="separator:ab8ab58bc06face6a1ca248352a22e1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c7a6c3ab2aa85b95ccf4209b897e2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#ad5c7a6c3ab2aa85b95ccf4209b897e2a">HwiP_post</a> (int interruptNum)</td></tr>
<tr class="memdesc:ad5c7a6c3ab2aa85b95ccf4209b897e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to generate an interrupt.  <a href="#ad5c7a6c3ab2aa85b95ccf4209b897e2a">More...</a><br /></td></tr>
<tr class="separator:ad5c7a6c3ab2aa85b95ccf4209b897e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a979cdfbd9993f6c5eedef8570efbd62e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a979cdfbd9993f6c5eedef8570efbd62e">HwiP_restore</a> (uintptr_t key)</td></tr>
<tr class="memdesc:a979cdfbd9993f6c5eedef8570efbd62e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to restore interrupts to exit a critical region.  <a href="#a979cdfbd9993f6c5eedef8570efbd62e">More...</a><br /></td></tr>
<tr class="separator:a979cdfbd9993f6c5eedef8570efbd62e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a74ad3ab90f488c0cb580ae77bef0d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a5a74ad3ab90f488c0cb580ae77bef0d0">HwiP_setFunc</a> (<a class="el" href="_hwi_p_8h.html#a7dd325ff62af296374efc6d317f5e368">HwiP_Handle</a> hwiP, <a class="el" href="_hwi_p_8h.html#a53a36fe33e22847927ceddbb63fb50c7">HwiP_Fxn</a> fxn, uintptr_t arg)</td></tr>
<tr class="memdesc:a5a74ad3ab90f488c0cb580ae77bef0d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to overwrite HwiP function and arg.  <a href="#a5a74ad3ab90f488c0cb580ae77bef0d0">More...</a><br /></td></tr>
<tr class="separator:a5a74ad3ab90f488c0cb580ae77bef0d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f317ac19a959dd999d7d99c83d1fbfa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#a1f317ac19a959dd999d7d99c83d1fbfa">HwiP_setPriority</a> (int interruptNum, uint32_t priority)</td></tr>
<tr class="memdesc:a1f317ac19a959dd999d7d99c83d1fbfa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to set the priority of a hardware interrupt.  <a href="#a1f317ac19a959dd999d7d99c83d1fbfa">More...</a><br /></td></tr>
<tr class="separator:a1f317ac19a959dd999d7d99c83d1fbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8920bde45f82b923fa5d4dd3b0b9fb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#aa8920bde45f82b923fa5d4dd3b0b9fb1">HwiP_dispatchInterrupt</a> (int interruptNum)</td></tr>
<tr class="memdesc:aa8920bde45f82b923fa5d4dd3b0b9fb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Function to call the HW ISR function registered by <a class="el" href="_hwi_p_8h.html#a9392b32717002e9447bd84181f323adb" title="Function to construct a hardware interrupt object. ">HwiP_construct()</a>  <a href="#aa8920bde45f82b923fa5d4dd3b0b9fb1">More...</a><br /></td></tr>
<tr class="separator:aa8920bde45f82b923fa5d4dd3b0b9fb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:acf51aa03ae02e5ce35e714c032a38f3f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_hwi_p_8h.html#acf51aa03ae02e5ce35e714c032a38f3f">HwiP_swiPIntNum</a></td></tr>
<tr class="memdesc:acf51aa03ae02e5ce35e714c032a38f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupt number posted by SwiP.  <a href="#acf51aa03ae02e5ce35e714c032a38f3f">More...</a><br /></td></tr>
<tr class="separator:acf51aa03ae02e5ce35e714c032a38f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a1fca150e7b36e480b092e0d9cbbb8721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fca150e7b36e480b092e0d9cbbb8721">&sect;&nbsp;</a></span>HwiP_STRUCT_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define HwiP_STRUCT_SIZE&#160;&#160;&#160;(28)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of bytes greater than or equal to the size of any RTOS HwiP object. </p>
<p>NoRTOS: 12 FreeRTOS: 12 BIOS 6.x: 28 BIOS 7.x: 20 </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a3ba69ca21548025e8d8babedd7ae2ea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba69ca21548025e8d8babedd7ae2ea1">&sect;&nbsp;</a></span>HwiP_Struct</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union <a class="el" href="union_hwi_p___struct.html">HwiP_Struct</a>  <a class="el" href="union_hwi_p___struct.html">HwiP_Struct</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>HwiP structure. </p>
<p>Opaque structure that should be large enough to hold any of the RTOS specific HwiP objects. </p>

</div>
</div>
<a id="a7dd325ff62af296374efc6d317f5e368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd325ff62af296374efc6d317f5e368">&sect;&nbsp;</a></span>HwiP_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void* <a class="el" href="_hwi_p_8h.html#a7dd325ff62af296374efc6d317f5e368">HwiP_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Opaque client reference to an instance of a HwiP. </p>
<p>A HwiP_Handle returned from the <a class="el" href="_hwi_p_8h.html#a3d80df47f0bdcbb6e562ee7b96a40af5" title="Function to create an interrupt on CortexM devices. ">HwiP_create()</a> represents that instance. </p>

</div>
</div>
<a id="a53a36fe33e22847927ceddbb63fb50c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53a36fe33e22847927ceddbb63fb50c7">&sect;&nbsp;</a></span>HwiP_Fxn</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* HwiP_Fxn) (uintptr_t arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prototype for the entry function for a hardware interrupt. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a8f508a9a62c31a942ffc9438f53dd258"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f508a9a62c31a942ffc9438f53dd258">&sect;&nbsp;</a></span>HwiP_Status</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="_hwi_p_8h.html#a8f508a9a62c31a942ffc9438f53dd258">HwiP_Status</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Status codes for HwiP APIs. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a8f508a9a62c31a942ffc9438f53dd258a96e82ebb87c2c36bba1fdd072fcec2f9"></a>HwiP_OK&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a8f508a9a62c31a942ffc9438f53dd258aa0988bb08bdcf17a219385320e200000"></a>HwiP_FAILURE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9392b32717002e9447bd84181f323adb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9392b32717002e9447bd84181f323adb">&sect;&nbsp;</a></span>HwiP_construct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_hwi_p_8h.html#a7dd325ff62af296374efc6d317f5e368">HwiP_Handle</a> HwiP_construct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_hwi_p___struct.html">HwiP_Struct</a> *&#160;</td>
          <td class="paramname"><em>hwiP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interruptNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_hwi_p_8h.html#a53a36fe33e22847927ceddbb63fb50c7">HwiP_Fxn</a>&#160;</td>
          <td class="paramname"><em>hwiFxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_hwi_p___params.html">HwiP_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to construct a hardware interrupt object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hwiP</td><td>Pointer to <a class="el" href="union_hwi_p___struct.html" title="HwiP structure. ">HwiP_Struct</a> object. </td></tr>
    <tr><td class="paramname">interruptNum</td><td>Interrupt Vector Id </td></tr>
    <tr><td class="paramname">hwiFxn</td><td>entry function of the hardware interrupt</td></tr>
    <tr><td class="paramname">params</td><td>Pointer to the instance configuration parameters. NULL denotes to use the default parameters. The HwiP default parameters are noted in <a class="el" href="_hwi_p_8h.html#a33f02161b1837b41f08ba064f1001045" title="Initialize params structure to default values. ">HwiP_Params_init()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A HwiP_Handle on success or a NULL on an error </dd></dl>

</div>
</div>
<a id="ad55b2c5937f748d643f8c3ffdeeabea2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55b2c5937f748d643f8c3ffdeeabea2">&sect;&nbsp;</a></span>HwiP_destruct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HwiP_destruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_hwi_p___struct.html">HwiP_Struct</a> *&#160;</td>
          <td class="paramname"><em>hwiP</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to destruct a hardware interrupt object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hwiP</td><td>Pointer to a <a class="el" href="union_hwi_p___struct.html" title="HwiP structure. ">HwiP_Struct</a> object that was passed to <a class="el" href="_hwi_p_8h.html#a9392b32717002e9447bd84181f323adb" title="Function to construct a hardware interrupt object. ">HwiP_construct()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="afe8d9c04a4f255f272ca690b25d59c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe8d9c04a4f255f272ca690b25d59c7e">&sect;&nbsp;</a></span>HwiP_clearInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HwiP_clearInterrupt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interruptNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to clear a single interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interruptNum</td><td>interrupt number to clear </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d80df47f0bdcbb6e562ee7b96a40af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d80df47f0bdcbb6e562ee7b96a40af5">&sect;&nbsp;</a></span>HwiP_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="_hwi_p_8h.html#a7dd325ff62af296374efc6d317f5e368">HwiP_Handle</a> HwiP_create </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interruptNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_hwi_p_8h.html#a53a36fe33e22847927ceddbb63fb50c7">HwiP_Fxn</a>&#160;</td>
          <td class="paramname"><em>hwiFxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_hwi_p___params.html">HwiP_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to create an interrupt on CortexM devices. </p>
<dl class="section note"><dt>Note</dt><dd>This function may not be available on all implementations</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interruptNum</td><td>Interrupt Vector Id</td></tr>
    <tr><td class="paramname">hwiFxn</td><td>entry function of the hardware interrupt</td></tr>
    <tr><td class="paramname">params</td><td>Pointer to the instance configuration parameters. NULL denotes to use the default parameters. The HwiP default parameters are noted in <a class="el" href="_hwi_p_8h.html#a33f02161b1837b41f08ba064f1001045" title="Initialize params structure to default values. ">HwiP_Params_init()</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A HwiP_Handle on success or a NULL on an error </dd></dl>

</div>
</div>
<a id="ab2e1c500e845723be6cd6e4caa58d6d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2e1c500e845723be6cd6e4caa58d6d7">&sect;&nbsp;</a></span>HwiP_delete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HwiP_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_hwi_p_8h.html#a7dd325ff62af296374efc6d317f5e368">HwiP_Handle</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to delete an interrupt on CortexM devices. </p>
<dl class="section note"><dt>Note</dt><dd>This function may not be available on all implementations</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">handle</td><td>returned from the HwiP_create call</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd></dd></dl>

</div>
</div>
<a id="aac47ffab62f7d25d736b58e40be17425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac47ffab62f7d25d736b58e40be17425">&sect;&nbsp;</a></span>HwiP_disable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t HwiP_disable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to disable interrupts to enter a critical region. </p>
<p>This function can be called multiple times, but must unwound in the reverse order. For example </p><div class="fragment"><div class="line">uintptr_t key1, key2;</div><div class="line">key1 = <a class="code" href="_hwi_p_8h.html#aac47ffab62f7d25d736b58e40be17425">HwiP_disable</a>();</div><div class="line">key2 = <a class="code" href="_hwi_p_8h.html#aac47ffab62f7d25d736b58e40be17425">HwiP_disable</a>();</div><div class="line"><a class="code" href="_hwi_p_8h.html#a979cdfbd9993f6c5eedef8570efbd62e">HwiP_restore</a>(key2);</div><div class="line"><a class="code" href="_hwi_p_8h.html#a979cdfbd9993f6c5eedef8570efbd62e">HwiP_restore</a>(key1);</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>A key that must be passed to <a class="el" href="_hwi_p_8h.html#a979cdfbd9993f6c5eedef8570efbd62e" title="Function to restore interrupts to exit a critical region. ">HwiP_restore()</a> to re-enable interrupts. </dd></dl>

</div>
</div>
<a id="a89a0a63fd819bbcb31064a60fc901629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a0a63fd819bbcb31064a60fc901629">&sect;&nbsp;</a></span>HwiP_enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HwiP_enable </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to enable interrupts. </p>

</div>
</div>
<a id="a2ab29f4a0e277d336338900c07151325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab29f4a0e277d336338900c07151325">&sect;&nbsp;</a></span>HwiP_disableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HwiP_disableInterrupt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interruptNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to disable a single interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interruptNum</td><td>interrupt number to disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a31f70cf8be574453b13dd9bfa4c8da26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31f70cf8be574453b13dd9bfa4c8da26">&sect;&nbsp;</a></span>HwiP_enableInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HwiP_enableInterrupt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interruptNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to enable a single interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interruptNum</td><td>interrupt number to enable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a06403da6ca0ed381d658fd4d54a3d294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06403da6ca0ed381d658fd4d54a3d294">&sect;&nbsp;</a></span>HwiP_inISR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HwiP_inISR </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to return a status based on whether it is in an interrupt context. </p>
<dl class="section return"><dt>Returns</dt><dd>A status: indicating whether the function was called in an ISR (true) or at thread level (false). </dd></dl>

</div>
</div>
<a id="a90a13fc52abcff27467ca5b5ff8a6f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a13fc52abcff27467ca5b5ff8a6f27">&sect;&nbsp;</a></span>HwiP_interruptsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool HwiP_interruptsEnabled </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to determine whether interrupts are currently enabled. </p>
<dl class="section return"><dt>Returns</dt><dd>Current state of interrupts.<ul>
<li>true Interrupts are currently enabled.</li>
<li>false Interrupts are currently disabled. </li>
</ul>
</dd></dl>

</div>
</div>
<a id="a33f02161b1837b41f08ba064f1001045"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f02161b1837b41f08ba064f1001045">&sect;&nbsp;</a></span>HwiP_Params_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HwiP_Params_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_hwi_p___params.html">HwiP_Params</a> *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize params structure to default values. </p>
<p>The default parameters are:</p><ul>
<li>arg: 0</li>
<li>priority: ~0</li>
<li>enableInt: true</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">params</td><td>Pointer to the instance configuration parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab8ab58bc06face6a1ca248352a22e1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8ab58bc06face6a1ca248352a22e1d0">&sect;&nbsp;</a></span>HwiP_plug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HwiP_plug </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interruptNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>fxn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to plug an interrupt vector. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interruptNum</td><td>ID of interrupt to plug </td></tr>
    <tr><td class="paramname">fxn</td><td>ISR that services plugged interrupt </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5c7a6c3ab2aa85b95ccf4209b897e2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5c7a6c3ab2aa85b95ccf4209b897e2a">&sect;&nbsp;</a></span>HwiP_post()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HwiP_post </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interruptNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to generate an interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interruptNum</td><td>ID of interrupt to generate </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a979cdfbd9993f6c5eedef8570efbd62e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a979cdfbd9993f6c5eedef8570efbd62e">&sect;&nbsp;</a></span>HwiP_restore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HwiP_restore </td>
          <td>(</td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to restore interrupts to exit a critical region. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>return from HwiP_disable </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5a74ad3ab90f488c0cb580ae77bef0d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a74ad3ab90f488c0cb580ae77bef0d0">&sect;&nbsp;</a></span>HwiP_setFunc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HwiP_setFunc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="_hwi_p_8h.html#a7dd325ff62af296374efc6d317f5e368">HwiP_Handle</a>&#160;</td>
          <td class="paramname"><em>hwiP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="_hwi_p_8h.html#a53a36fe33e22847927ceddbb63fb50c7">HwiP_Fxn</a>&#160;</td>
          <td class="paramname"><em>fxn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to overwrite HwiP function and arg. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hwiP</td><td>handle returned from the HwiP_create or construct call </td></tr>
    <tr><td class="paramname">fxn</td><td>pointer to ISR function </td></tr>
    <tr><td class="paramname">arg</td><td>argument to ISR function </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1f317ac19a959dd999d7d99c83d1fbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f317ac19a959dd999d7d99c83d1fbfa">&sect;&nbsp;</a></span>HwiP_setPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HwiP_setPriority </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interruptNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>priority</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to set the priority of a hardware interrupt. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interruptNum</td><td>id of the interrupt to change </td></tr>
    <tr><td class="paramname">priority</td><td>new priority </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa8920bde45f82b923fa5d4dd3b0b9fb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8920bde45f82b923fa5d4dd3b0b9fb1">&sect;&nbsp;</a></span>HwiP_dispatchInterrupt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void HwiP_dispatchInterrupt </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>interruptNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Function to call the HW ISR function registered by <a class="el" href="_hwi_p_8h.html#a9392b32717002e9447bd84181f323adb" title="Function to construct a hardware interrupt object. ">HwiP_construct()</a> </p>
<dl class="section note"><dt>Note</dt><dd>This function may not be available on all implementations</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">interruptNum</td><td>Interrupt Vector Id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="acf51aa03ae02e5ce35e714c032a38f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf51aa03ae02e5ce35e714c032a38f3f">&sect;&nbsp;</a></span>HwiP_swiPIntNum</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int HwiP_swiPIntNum</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupt number posted by SwiP. </p>
<p>The SwiP module needs its scheduler to run at key points in SwiP processing. This is accomplished via an interrupt that is configured at the lowest possible interrupt priority level and is plugged with the SwiP scheduler. This interrupt must be the <em>only</em> interrupt at that lowest priority. SwiP will post this interrupt whenever its scheduler needs to run.</p>
<p>The default value for your device should suffice, but if a different interrupt is needed to be used for SwiP scheduling then HwiP_swiPIntNum can be assigned with this interrupt (early on, before HwiPs are created and before any SwiP gets posted). </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml"> Copyright 1995-2024</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
