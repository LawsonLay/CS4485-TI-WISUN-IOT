<!-- HTML header for doxygen 1.8.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.12"/>
<title>LogSinkUART.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link id="favicon" rel="shortcut icon" type="image/x-icon" href="favicon.ico"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="tiapistylesheet.css" rel="stylesheet" type="text/css" />
</head>
<body>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="https://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_b2f33c71d4aa5e7af42a1ca61ff5af1b.html">source</a></li><li class="navelem"><a class="el" href="dir_dd8fa7f0a423552d37651735ac37558f.html">ti</a></li><li class="navelem"><a class="el" href="dir_9baa04f1329cf92a22a2a22f9d5e6ed2.html">log</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">LogSinkUART.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><b>PRELIMINARY</b> LogSinkUART interface </p>
<hr/>
<dl class="section warning"><dt>Warning</dt><dd>These APIs are <b>PRELIMINARY</b></dd></dl>
<p>The LogSinkUART module is a sink that can be used in conjunction with the Log.h API in source/ti/log/ and the logging tools available in tools/log/tiutils. The API defined in this file is made available to the Logging framework and used as a transport layer for Log.h. For more information about the Log API, see the <a class="el" href="index.html#log">Log documentation</a>.</p>
<p>To use the UART sink, ensure that the correct library for your device is linked in and include this header file as follows: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_log_sink_u_a_r_t_8h.html">ti/log/LogSinkUART.h</a>&gt;</span></div></div><!-- fragment --><p>This module implements two functions that are required by the Log API:</p><ul>
<li>printf(const Log_Module *handle, uint32_t header, uint32_t headerPtr, uint32_t numArgs, ...);</li>
<li>buf(const Log_Module *handle, uint32_t header, uint32_t headerPtr, uint8_t *data, size_t size);</li>
</ul>
<p>Whenever a log statement that uses LogSinkUART as its sink is called, the log module delegates to one of the functions above.</p>
<p><a class="anchor" id="ti_log_LogSinkUART_Overview"></a></p><h1>Overview</h1>
<p>LogSinkUART is a sink/transport layer that asynchronously outputs encoded log statements over UART. It uses the UART2 driver to stream data out onto a user-selectable pin, which can be received and processed by a host-side tool. For more information about the host-side tool, see tools/log/tiutils.</p>
<p>At the log-site the sink separates the generation of the log record from the transportation of the record off the device. Deferring the transportation to a later point of the program execution is done to minimize the runtime intrusion that would be caused by synchronously outputting the log statements through the relatively slow UART. The first part generates and stores the log statements into an intermediate storage synchronously. The second part uses the idle task of the OS, executed when no other tasks or interrupts are running, to move the data stored in the intermediate storage off the device.</p>
<p>By transmitting messages asynchronously the readout at the host-side is also asynchronous. As a consequence, the receiving of log statements at the host-side can be deferred from their execution in the program.</p>
<p>This sink requires no special hardware to capture and decode the logs beyond a basic UART-to-USB bridge.</p>
<p>The data flow at a high level is:</p><ol type="1">
<li>Log statement captured at the log site with timestamp</li>
<li>Log data marshalled into a log packet</li>
<li>Log packet moved to ring buffer working as intermediate storage</li>
<li>Intermediate storage flushed via the UART2 driver when nothing else is happening through a function installed in the Idle-loop/task</li>
<li>Data sent out on the UART line</li>
<li>Data received by listening COM port on host</li>
<li>Data decoded by host and fed through remainder of host logging infrastructure</li>
<li>Logs visualised in Wireshark or dumped to console / log file</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Throughout this documentation and API the term "packet" is used instead of the term "record". Both terms are equivalent and can be used interchangeably.</dd></dl>
<hr/>
<p> <a class="anchor" id="ti_log_LogSinkUART_Considerations"></a></p><h1>Considerations</h1>
<p>When using this sink consider the following:</p><ul>
<li>The number of sinks is limited by the number of UART peripherals in the device.</li>
<li>When a UART instance is consumed for a sink it can not be used for other operations.</li>
<li>When a single UART LogSink instance is used, an optimised printf is used that reduces the footprint of each #Log_printf statement.</li>
<li>Each UART LogSink will create its own Ring Buffer.</li>
<li>If any part of the transmission is lost/not received by the logging-tool, the rest of the data might not be interpreted correctly.</li>
<li>9.54 hours of logging timestamps are available before overflowing in a system where 1 bit = 8 us. The tick period for each device can be read from the multiplier variable in TimestamP&lt;device&gt;.c under kernel/freertos/dpl. If the timestamp overflows it will go back to 0.</li>
<li>The LogSinkUART sinks are flushed in the order they are instantiated. </li>
<li>If performance issues are observed either increase the size of the UART2 ring buffer to increase throughput or increase the size of the intermediate ring buffer size for more log statements. Also note that the device needs to have idle-time to automatically flush data. If the software is always doing something then nothing will ever be output.</li>
<li>SRAM requirements scale with the number of log records to store in between flushing the buffer.</li>
<li>A #Log_printf call has an execution time of 20 us to 27.8 us depending on the number of arguments.</li>
<li>A Log_buf call has a minimum execution time of 32.8 us and an approximate increase of 0.183 us per byte in the buffer.</li>
</ul>
<hr/>
<p> <a class="anchor" id="ti_log_LogSinkUART_DesignArchitecture"></a></p><h1>Design Architecture</h1>
<p>The LogSinkUART implementation is based on the following architecture.</p>
<h2>Packet Transmission Format</h2>
<p>All log packets begin with a 32-bit metadata pointer followed by a 32-bit timestamp. The next fields depend on the type of log statement:</p><ul>
<li>Log_printf: Variable number of 32-bit arguments that range from 0 to 8.</li>
<li>Log_buf: 32-bit field with the size of the buffer being sent followed by the buffer data.</li>
</ul>
<div align="center">
<img src="inline_umlgraph_1.png" />
</div>
<p>If a packet would overflow the ring buffer, a 32-bit overflow packet is placed instead. It is the original metadata pointer modified to be identified as an overflow packet. The host-side tool decodes it and displays an overflow message, indicating that at least that message would have overflowed. When this is observed, it is recommended to either resize the ring buffer or disable some log statements. </p><dl class="section note"><dt>Note</dt><dd>If the intermediate ring buffer is full, no new overflow or log packets will be stored.</dd></dl>
<p>Each log statement used will occupy the following amount of SRAM:</p>
<table class="doxtable">
<tr>
<th>Log statement type </th><th>Log statement size (bytes)  </th></tr>
<tr>
<td>Log_printf </td><td>8 + 4 * number_of_arguments </td></tr>
<tr>
<td>Log_buf </td><td>12 + buffer_size </td></tr>
<tr>
<td>Overflow </td><td>4 </td></tr>
</table>
<h2>Packet Framing</h2>
<p>The host-side must receive and properly handle a continuous stream of packets. It is able to decode and synchronize packets. If the first 32 bits is not a valid metadata-pointer address, it will left-shift byte-by-byte until it detects a valid one. Once a metadata-pointer address is verified, the host-side tool knows that it is followed by a timestamp. The number of arguments for each frame is extracted from the .out file. This determines the length of the current packet and when the metadata-pointer address from the next packet is expected.</p>
<h2>Flushing the data</h2>
<p>A hook function installed in the Idle-loop/task is run when no other tasks or interrupts are running. It flushes as many log packets as possible from the intermediate storage via the UART2 driver set in nonblocking mode. In this mode, <a class="el" href="_u_a_r_t2_8h.html#a85ec2c5906ad36adc14cddd011b3b7cf" title="Function that writes data to a UART. ">UART2_write()</a> will copy as much data into the transmit buffer as space allows and return immediately. The maximum space allowed, and therefore the amount of data sent out every time that the hook function is called, is determined by the size of the TX Ring Buffer.</p>
<p>The Idle-loop/task will always be run before the power management loop.</p>
<p>Since each OS has a different implementation of the Idle-loop/task, the installation of the hook function will also be different for each OS. The automatic installation is currently supported for FreeRTOS and TI-RTOS 7 when using SysConfig.</p>
<hr/>
<p> <a class="anchor" id="ti_log_LogSinkUART_Usage"></a></p><h1>Usage</h1>
<p>To use the UART LogSink the application calls the following APIs:</p><ul>
<li><a class="el" href="_log_sink_u_a_r_t_8h.html#a9c1b1047b094b8b706cd774508d1c514" title="Initialize a given LogSinkUART sink. ">LogSinkUART_init()</a>: Initialize a UART sink. This function takes as argument an index that describes the sink that has to be initialized.</li>
<li><a class="el" href="_log_sink_u_a_r_t_8h.html#aaa81127b20cfa3f88df0f435cc5c932e" title="Flush all the LogSinkUART sinks. ">LogSinkUART_flush()</a>: Function to flush all the LogSinkUART sinks in the order they are added. For each sink it will read data from the ring buffer and put as much as possible on the UART interface.</li>
<li><a class="el" href="_log_sink_u_a_r_t_8h.html#a1a2c675dc927953a2f5bc6dc1c564ed5" title="Finalize a given LogSinkUART sink. ">LogSinkUART_finalize()</a>: Finalize a UART sink. This function takes as argument an index that describes the sink that has to be finalized.</li>
</ul>
<p>Details on usage are provided in the following subsections.</p>
<p><a class="anchor" id="ti_log_LogSinkUART_Examples"></a></p><h2>Examples</h2>
<ul>
<li><a class="el" href="_log_sink_u_a_r_t_8h.html#ti_log_LogSinkUART_initialize">Initializing a UART LogSink</a></li>
<li><a class="el" href="_log_sink_u_a_r_t_8h.html#ti_log_LogSinkUART_flush">Flushing UART sinks</a></li>
<li><a class="el" href="_log_sink_u_a_r_t_8h.html#ti_log_LogSinkUART_finalize">Finalizing a UART LogSink</a></li>
<li><a class="el" href="_log_sink_u_a_r_t_8h.html#ti_log_LogSinkUART_protect">Protect log statements</a></li>
</ul>
<p><a class="anchor" id="ti_log_LogSinkUART_initialize"></a></p><h3>Initializing a UART LogSink</h3>
<p>If LogSinkUART is enabled through SysConfig, then <a class="el" href="_log_sink_u_a_r_t_8h.html#a9c1b1047b094b8b706cd774508d1c514" title="Initialize a given LogSinkUART sink. ">LogSinkUART_init()</a> will be automatically called from <a class="el" href="_board_8h.html#a6c191e6138454022bba4dbcb4278f141" title="Performs &quot;early&quot; board-level initialization required by TI-DRIVERS. ">Board_init()</a>. If SysConfig is not used, the user must initialize the log sink. <a class="el" href="_log_sink_u_a_r_t_8h.html#a9c1b1047b094b8b706cd774508d1c514" title="Initialize a given LogSinkUART sink. ">LogSinkUART_init()</a> can also be called after a sink has been finalized with <a class="el" href="_log_sink_u_a_r_t_8h.html#a1a2c675dc927953a2f5bc6dc1c564ed5" title="Finalize a given LogSinkUART sink. ">LogSinkUART_finalize()</a>. To initialize a sink, first include the ti_log_config.h library containing the expansion of the sink name. Afterwards, call the initialize function passing as an argument the name of the sink to be initialized.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ti_log_config.h&quot;</span></div><div class="line"></div><div class="line"><a class="code" href="_log_sink_u_a_r_t_8h.html#a9c1b1047b094b8b706cd774508d1c514">LogSinkUART_init</a>(sink_name);</div></div><!-- fragment --><p><a class="anchor" id="ti_log_LogSinkUART_flush"></a></p><h3>Flushing UART sinks</h3>
<p><a class="el" href="_log_sink_u_a_r_t_8h.html#aaa81127b20cfa3f88df0f435cc5c932e" title="Flush all the LogSinkUART sinks. ">LogSinkUART_flush()</a> will be called automatically in the Idle-loop/task for FreeRTOS and TI-RTOS 7. Despite this, the user can still manually call the function to send out as much data as possible from all the existing ring buffers when desired. The flush function can be called from either a task or interrupt context.</p>
<p><a class="anchor" id="ti_log_LogSinkUART_finalize"></a></p><h3>Finalizing a UART LogSink</h3>
<p><a class="el" href="_log_sink_u_a_r_t_8h.html#a1a2c675dc927953a2f5bc6dc1c564ed5" title="Finalize a given LogSinkUART sink. ">LogSinkUART_finalize()</a> will cancel all ongoing UART writes and call <a class="el" href="_u_a_r_t2_8h.html#a2a82f370c2f15ececc5b03fbba65bcde" title="Function to close a UART peripheral specified by the UART2 handle. ">UART2_close()</a>. All log packets remaining in the intermediate storage will be lost when calling <a class="el" href="_log_sink_u_a_r_t_8h.html#a9c1b1047b094b8b706cd774508d1c514" title="Initialize a given LogSinkUART sink. ">LogSinkUART_init()</a> because the ring buffer will be reset. All log statements after a finalize call will also be lost due to the reset of the ring buffer when initializing the sink. To finalize a sink first include the ti_log_config.h library containing the expansion of the sink name. Afterwards, call the finalize function passing as an argument the name of the sink to be finalized.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ti_log_config.h&quot;</span></div><div class="line"></div><div class="line"><a class="code" href="_log_sink_u_a_r_t_8h.html#a1a2c675dc927953a2f5bc6dc1c564ed5">LogSinkUART_finalize</a>(sink_name);</div></div><!-- fragment --><p><a class="anchor" id="ti_log_LogSinkUART_protect"></a></p><h3>Protect log statements</h3>
<p>To ensure that logs are correctly ordered when put back together on the host, log statements can be called from a context where HWI are disabled. This also ensures that the recorded timestamp is faithful to when the log statement was executed.</p>
<p>Logs can end up ordered out as a consequence of a log call being preempted by a higher priority task with other log statements. The following example shows how a log statement can be protected to ensure that the execution sequence is maintained in the ordering on the host-side.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_hwi_p_8h.html">ti/drivers/dpl/HwiP.h</a>&gt;</span></div><div class="line">uint32_t key;</div><div class="line"></div><div class="line">key = <a class="code" href="_hwi_p_8h.html#aac47ffab62f7d25d736b58e40be17425">HwiP_disable</a>();</div><div class="line">Log_printf(MyModule, Log_DEBUG, <span class="stringliteral">&quot;The answer is %d&quot;</span>, 42);</div><div class="line"><a class="code" href="_hwi_p_8h.html#a979cdfbd9993f6c5eedef8570efbd62e">HwiP_restore</a>(key);</div></div><!-- fragment --><hr/>
<p> <a class="anchor" id="ti_log_LogSinkUART_Configuration"></a></p><h1>Configuration</h1>
<p>In order to use the LogSinkUART APIs, the application is required to provide sink-specific configuration in the ti_log_config.c file. The LogSinkUART interface defines a configuration data structure:</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct  </span>{</div><div class="line">    <span class="keywordtype">void</span>                   *object;</div><div class="line">    <span class="keywordtype">void</span>          <span class="keyword">const</span>    *hwAttrs;</div><div class="line">} <a class="code" href="struct_log_sink_u_a_r_t___config.html">LogSinkUART_Config</a>;</div></div><!-- fragment --><p>The application must declare an array of <a class="el" href="struct_log_sink_u_a_r_t___config.html" title="LogSinkUART Global configuration. ">LogSinkUART_Config</a> elements, named <code>LogSinkUART_config</code>[]. Each element of <code>LogSinkUART_config</code>[] must be populated with pointers to a sink specific object, and hardware attributes. The hardware attributes define properties such as the UART peripheral's attributes, and a pointer to the intermediate ring buffer and its size. These are automatically assigned through SysConfig. Each element in <code>LogSinkUART_config</code>[] corresponds to a UART sink instance, and none of the elements should have NULL pointers.</p>
<p>The configuration for the UART LogSink is based on the driver's configuration. Refer to the <a class="el" href="index.html#driver_configuration">Driver's Configuration</a> section for driver configuration information.</p>
<p>To automatically initialize a UART sink when initializing the board, <a class="el" href="_log_sink_u_a_r_t_8h.html#a9c1b1047b094b8b706cd774508d1c514" title="Initialize a given LogSinkUART sink. ">LogSinkUART_init()</a> is called inside <a class="el" href="_board_8h.html#a6c191e6138454022bba4dbcb4278f141" title="Performs &quot;early&quot; board-level initialization required by TI-DRIVERS. ">Board_init()</a> in ti_drivers_config.c. To have access to the function and get the expansion of the sink name, include the following libraries:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ti_log_config.h&quot;</span></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="_log_sink_u_a_r_t_8h.html">ti/log/LogSinkUART.h</a>&gt;</span></div></div><!-- fragment --> <hr/>
</div><div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;ti/log/Log.h&gt;</code><br />
<code>#include &lt;<a class="el" href="_u_a_r_t2_8h_source.html">ti/drivers/UART2.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="_ring_buf_8h_source.html">ti/drivers/utils/RingBuf.h</a>&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for LogSinkUART.h:</div>
<div class="dyncontent">
<div class="center"><img src="_log_sink_u_a_r_t_8h__incl.png" border="0" usemap="#_log_sink_u_a_r_t_8h" alt=""/></div>
<map name="_log_sink_u_a_r_t_8h" id="_log_sink_u_a_r_t_8h">
<area shape="rect" id="node5" href="_u_a_r_t2_8h.html" title="PRELIMINARY UART driver interface " alt="" coords="1069,80,1208,107"/>
<area shape="rect" id="node17" href="_ring_buf_8h.html" title="ti/drivers/utils/RingBuf.h" alt="" coords="1125,468,1304,495"/>
<area shape="rect" id="node7" href="_power_8h.html" title="Power Manager. " alt="" coords="567,155,702,181"/>
<area shape="rect" id="node11" href="_hwi_p_8h.html" title="Hardware Interrupt module for the RTOS Porting Interface. " alt="" coords="849,468,999,495"/>
<area shape="rect" id="node12" href="_clock_p_8h.html" title="Clock interface for the RTOS Porting Interface. " alt="" coords="888,386,1051,413"/>
<area shape="rect" id="node16" href="_semaphore_p_8h.html" title="Semaphore module for the RTOS Porting Interface. " alt="" coords="296,468,496,495"/>
<area shape="rect" id="node8" href="_list_8h.html" title="Linked List interface for use in drivers. " alt="" coords="521,468,671,495"/>
<area shape="rect" id="node10" href="_power_c_c26_x_x_8h.html" title="Power manager interface for CC26XX/CC13XX. " alt="" coords="595,229,827,256"/>
<area shape="rect" id="node13" href="_power_c_c26_x2_8h.html" title="Power manager interface for CC26X2. " alt="" coords="595,304,826,331"/>
<area shape="rect" id="node14" href="_temperature_8h.html" title="Temperature driver. " alt="" coords="405,386,584,413"/>
</map>
</div>
</div>
<p><a href="_log_sink_u_a_r_t_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_log_sink_u_a_r_t___h_w_attrs.html">LogSinkUART_HWAttrs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LogSinkUART Hardware attributes.  <a href="struct_log_sink_u_a_r_t___h_w_attrs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_log_sink_u_a_r_t___object.html">LogSinkUART_Object</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LogSinkUART Object.  <a href="struct_log_sink_u_a_r_t___object.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_log_sink_u_a_r_t___config.html">LogSinkUART_Config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LogSinkUART Global configuration.  <a href="struct_log_sink_u_a_r_t___config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_log_sink_u_a_r_t___instance.html">LogSinkUART_Instance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">LogSinkUART Sink parameters.  <a href="struct_log_sink_u_a_r_t___instance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ac679e435e04bde56398753bdcec55ff2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_log_sink_u_a_r_t_8h.html#ac679e435e04bde56398753bdcec55ff2">Log_TI_LOG_SINK_UART_VERSION</a>&#160;&#160;&#160;0.1.0</td></tr>
<tr class="memdesc:ac679e435e04bde56398753bdcec55ff2"><td class="mdescLeft">&#160;</td><td class="mdescRight">LogSinkUART version.  <a href="#ac679e435e04bde56398753bdcec55ff2">More...</a><br /></td></tr>
<tr class="separator:ac679e435e04bde56398753bdcec55ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a5cb6dc581c2c08f06259b42389ae96"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_log_sink_u_a_r_t_8h.html#a2a5cb6dc581c2c08f06259b42389ae96">Log_SINK_UART_DEFINE</a>(name)&#160;&#160;&#160;<a class="el" href="struct_log_sink_u_a_r_t___instance.html">LogSinkUART_Instance</a> LogSinkUART_##name##_Config = {.index = name}</td></tr>
<tr class="memdesc:a2a5cb6dc581c2c08f06259b42389ae96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a LogSinkUART instance called <code>name</code>.  <a href="#a2a5cb6dc581c2c08f06259b42389ae96">More...</a><br /></td></tr>
<tr class="separator:a2a5cb6dc581c2c08f06259b42389ae96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d312a1edf53bb5574d5f671ab2917a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_log_sink_u_a_r_t_8h.html#a48d312a1edf53bb5574d5f671ab2917a">Log_SINK_UART_USE</a>(name)&#160;&#160;&#160;extern <a class="el" href="struct_log_sink_u_a_r_t___instance.html">LogSinkUART_Instance</a> LogSinkUART_##name##_Config</td></tr>
<tr class="memdesc:a48d312a1edf53bb5574d5f671ab2917a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use a LogSinkUART instance called <code>name</code> when not created in the same file.  <a href="#a48d312a1edf53bb5574d5f671ab2917a">More...</a><br /></td></tr>
<tr class="separator:a48d312a1edf53bb5574d5f671ab2917a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b70fafc4d748f50abff56317a7d896"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_log_sink_u_a_r_t_8h.html#a34b70fafc4d748f50abff56317a7d896">Log_MODULE_INIT_SINK_UART</a>(name,  _levels,  printfDelegate,  bufDelegate,  _dynamicLevelsPtr)</td></tr>
<tr class="memdesc:a34b70fafc4d748f50abff56317a7d896"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a LogSinkUART instance called <code>name</code> with log <code>_levels</code> , printf delegate function <code>printfDelegate</code> , buf delegate function <code>bufDelegate</code> and dynamic log level <code>_dynamicLevelsPtr</code>.  <a href="#a34b70fafc4d748f50abff56317a7d896">More...</a><br /></td></tr>
<tr class="separator:a34b70fafc4d748f50abff56317a7d896"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab152d4c3b9cf998c4f85bc70b3c05f89"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="struct_log_sink_u_a_r_t___instance.html">LogSinkUART_Instance</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_log_sink_u_a_r_t_8h.html#ab152d4c3b9cf998c4f85bc70b3c05f89">LogSinkUART_Handle</a></td></tr>
<tr class="memdesc:ab152d4c3b9cf998c4f85bc70b3c05f89"><td class="mdescLeft">&#160;</td><td class="mdescRight">A handle for the <a class="el" href="struct_log_sink_u_a_r_t___instance.html" title="LogSinkUART Sink parameters. ">LogSinkUART_Instance</a> structure.  <a href="#ab152d4c3b9cf998c4f85bc70b3c05f89">More...</a><br /></td></tr>
<tr class="separator:ab152d4c3b9cf998c4f85bc70b3c05f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aaa81127b20cfa3f88df0f435cc5c932e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_log_sink_u_a_r_t_8h.html#aaa81127b20cfa3f88df0f435cc5c932e">LogSinkUART_flush</a> (void)</td></tr>
<tr class="memdesc:aaa81127b20cfa3f88df0f435cc5c932e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flush all the LogSinkUART sinks.  <a href="#aaa81127b20cfa3f88df0f435cc5c932e">More...</a><br /></td></tr>
<tr class="separator:aaa81127b20cfa3f88df0f435cc5c932e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1b1047b094b8b706cd774508d1c514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_log_sink_u_a_r_t_8h.html#a9c1b1047b094b8b706cd774508d1c514">LogSinkUART_init</a> (uint_least8_t index)</td></tr>
<tr class="memdesc:a9c1b1047b094b8b706cd774508d1c514"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a given LogSinkUART sink.  <a href="#a9c1b1047b094b8b706cd774508d1c514">More...</a><br /></td></tr>
<tr class="separator:a9c1b1047b094b8b706cd774508d1c514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2c675dc927953a2f5bc6dc1c564ed5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_log_sink_u_a_r_t_8h.html#a1a2c675dc927953a2f5bc6dc1c564ed5">LogSinkUART_finalize</a> (uint_least8_t index)</td></tr>
<tr class="memdesc:a1a2c675dc927953a2f5bc6dc1c564ed5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finalize a given LogSinkUART sink.  <a href="#a1a2c675dc927953a2f5bc6dc1c564ed5">More...</a><br /></td></tr>
<tr class="separator:a1a2c675dc927953a2f5bc6dc1c564ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a234596f869caa19cc28c770545aac882"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="struct_log_sink_u_a_r_t___config.html">LogSinkUART_Config</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="_log_sink_u_a_r_t_8h.html#a234596f869caa19cc28c770545aac882">LogSinkUART_config</a> []</td></tr>
<tr class="memdesc:a234596f869caa19cc28c770545aac882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array with the configuration of each sink.  <a href="#a234596f869caa19cc28c770545aac882">More...</a><br /></td></tr>
<tr class="separator:a234596f869caa19cc28c770545aac882"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ac679e435e04bde56398753bdcec55ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac679e435e04bde56398753bdcec55ff2">&sect;&nbsp;</a></span>Log_TI_LOG_SINK_UART_VERSION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Log_TI_LOG_SINK_UART_VERSION&#160;&#160;&#160;0.1.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>LogSinkUART version. </p>

</div>
</div>
<a id="a2a5cb6dc581c2c08f06259b42389ae96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a5cb6dc581c2c08f06259b42389ae96">&sect;&nbsp;</a></span>Log_SINK_UART_DEFINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Log_SINK_UART_DEFINE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="struct_log_sink_u_a_r_t___instance.html">LogSinkUART_Instance</a> LogSinkUART_##name##_Config = {.index = name}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a LogSinkUART instance called <code>name</code>. </p>
<p>NODOC NODOC NODOC </p>

</div>
</div>
<a id="a48d312a1edf53bb5574d5f671ab2917a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d312a1edf53bb5574d5f671ab2917a">&sect;&nbsp;</a></span>Log_SINK_UART_USE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Log_SINK_UART_USE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name</td><td>)</td>
          <td>&#160;&#160;&#160;extern <a class="el" href="struct_log_sink_u_a_r_t___instance.html">LogSinkUART_Instance</a> LogSinkUART_##name##_Config</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use a LogSinkUART instance called <code>name</code> when not created in the same file. </p>

</div>
</div>
<a id="a34b70fafc4d748f50abff56317a7d896"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b70fafc4d748f50abff56317a7d896">&sect;&nbsp;</a></span>Log_MODULE_INIT_SINK_UART</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Log_MODULE_INIT_SINK_UART</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">name, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_levels, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">printfDelegate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">bufDelegate, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">_dynamicLevelsPtr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{                                                                                                                 \</div><div class="line">        .sinkConfig = &amp;LogSinkUART_##name##_Config, .printf = printfDelegate, .printf0 = printfDelegate##0,           \</div><div class="line">        .printf1 = printfDelegate##1, .printf2 = printfDelegate##2, .printf3 = printfDelegate##3, .buf = bufDelegate, \</div><div class="line">        .levels = _levels, .dynamicLevelsPtr = _dynamicLevelsPtr,                                                     \</div><div class="line">    }</div></div><!-- fragment -->
<p>Initialize a LogSinkUART instance called <code>name</code> with log <code>_levels</code> , printf delegate function <code>printfDelegate</code> , buf delegate function <code>bufDelegate</code> and dynamic log level <code>_dynamicLevelsPtr</code>. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ab152d4c3b9cf998c4f85bc70b3c05f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab152d4c3b9cf998c4f85bc70b3c05f89">&sect;&nbsp;</a></span>LogSinkUART_Handle</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="struct_log_sink_u_a_r_t___instance.html">LogSinkUART_Instance</a>* <a class="el" href="_log_sink_u_a_r_t_8h.html#ab152d4c3b9cf998c4f85bc70b3c05f89">LogSinkUART_Handle</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A handle for the <a class="el" href="struct_log_sink_u_a_r_t___instance.html" title="LogSinkUART Sink parameters. ">LogSinkUART_Instance</a> structure. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aaa81127b20cfa3f88df0f435cc5c932e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa81127b20cfa3f88df0f435cc5c932e">&sect;&nbsp;</a></span>LogSinkUART_flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LogSinkUART_flush </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flush all the LogSinkUART sinks. </p>
<p>Function to flush each of the LogSinkUART sinks in the order they are added. For each sink it will read its ring buffer and put as much data as possible on the UART interface. The flush can occur in task or interrupt context. </p>

</div>
</div>
<a id="a9c1b1047b094b8b706cd774508d1c514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1b1047b094b8b706cd774508d1c514">&sect;&nbsp;</a></span>LogSinkUART_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LogSinkUART_init </td>
          <td>(</td>
          <td class="paramtype">uint_least8_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a given LogSinkUART sink. </p>
<p>Function to initialize a given LogSinkUART sink specified by the particular index value. It constructs a ring buffer, sets up the UART2 attributes and opens the given UART peripheral</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Logical sink number for the LogSinkUART indexed into the LogSinkUART_config table</td></tr>
  </table>
  </dd>
</dl>
<p>The UART peripheral is set to send only mode, with the following fixed parameters: </p><div class="fragment"><div class="line">writeMode = <a class="code" href="_u_a_r_t2_8h.html#a5bfa1a3442db9943342497e519a08863a385b6370d2fa01027d19907c6e593e1b">UART2_Mode_NONBLOCKING</a>;</div><div class="line">dataLength = <a class="code" href="_u_a_r_t2_8h.html#a6c14675701ba732f156c2eea7e3f6515abcb7ead4413215f0473c368f284ef729">UART2_DataLen_8</a>;</div><div class="line">stopBits = <a class="code" href="_u_a_r_t2_8h.html#ae0d2d6413d7e338fd053569d848c239faa707a48589e67b81ac5a2f22342070e9">UART2_StopBits_1</a>;</div></div><!-- fragment --><p>The baudRate and parityType can be configured from SysConfig. The size of the ring buffer can also be set from the SysConfig. </p>

</div>
</div>
<a id="a1a2c675dc927953a2f5bc6dc1c564ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2c675dc927953a2f5bc6dc1c564ed5">&sect;&nbsp;</a></span>LogSinkUART_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LogSinkUART_finalize </td>
          <td>(</td>
          <td class="paramtype">uint_least8_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finalize a given LogSinkUART sink. </p>
<p>Function to finalize a given LogSinkUART sink specified by the particular index value. It cancels any ongoing write operation over the given UART peripheral and closes it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>Logical sink number for the LogSinkUART indexed into the LogSinkUART_config table </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a234596f869caa19cc28c770545aac882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234596f869caa19cc28c770545aac882">&sect;&nbsp;</a></span>LogSinkUART_config</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="struct_log_sink_u_a_r_t___config.html">LogSinkUART_Config</a> LogSinkUART_config[]</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Array with the configuration of each sink. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><small>
  <a href="https://www.ti.com/corp/docs/legal/copyright.shtml">© Copyright 1995-2024</a>, Texas Instruments Incorporated. All rights reserved. <br/>
  <a href="https://www.ti.com/corp/docs/legal/trademark/trademrk.htm">Trademarks</a> | <a href="https://www.ti.com/corp/docs/legal/privacy.shtml">Privacy policy</a> | <a href="https://www.ti.com/corp/docs/legal/termsofuse.shtml">Terms of use</a> | <a href="https://www.ti.com/lsds/ti/legal/termsofsale.page">Terms of sale</a>
</small>
</body>
</html>
